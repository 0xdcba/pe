<!DOCTYPE html>
<html lang="ru">
<head>
	
	<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<meta name="keywords" content="эрланг, erlang, компиляция, компиляция программ, компилирование, компилирование программ, команды оболочки, команды, оболочка">


<meta name="description" content="Модель программирования Эрланга — это то как мы, на самом деле, думаем и взаимодействуем. Джо Армстронг">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="http://bootstrap-3.ru/assets/ico/favicon.ico">

<title>Глава 6. Компилирование и запуск ваших программ</title>

<!-- Bootstrap core CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">

<!--bootstrap material design-->
        <link href="/css/ripples.min.css" rel="stylesheet">
        <link href="/css/material-wfont.min.css" rel="stylesheet">

<!-- Custom styles for this template -->
<link href="/css/theme.css" rel="stylesheet">
<link href="/css/pygments.css" rel="stylesheet">

<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

	
</head>
<body>
	
	<!--LiveInternet counter--><script type="text/javascript"><!--
new Image().src = "//counter.yadro.ru/hit?r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";h"+escape(document.title.substring(0,80))+
";"+Math.random();//--></script><!--/LiveInternet-->


	
	<div class="container">
		<!-- main menu-->
		<menu>
			<div class="container" role="navigation">
<ul class="nav nav-pills nav-justified">

	<li role="presentation" >
		<a class="menu_item" style="color:white" href="http://erlangbook.tk/index.html">Главная</a>
	</li>

	<li role="presentation" >
		<a class="menu_item" style="color:white" href="http://erlangbook.tk/chapters.html">Оглавление</a>
	</li>

	<li role="presentation" >
		<a class="menu_item" style="color:white" href="http://erlangbook.tk/download.html">Скачать книгу</a>
	</li>

	<li role="presentation" >
		<a class="menu_item" style="color:white" href="http://erlangbook.tk/about_translation.html">О переводе</a>
	</li>

</ul>
</div>

		</menu>
		
		
		<!-- page content -->
		<div class="jumbotron" >
			<h1 class="cover-heading">Глава 6. Компилирование и запуск ваших программ</h1>
			<p>В предыдущих главах, мы мало говорили о компиляции и запуске программ - мы просто использовали оболочку Эрланг. Это вполне нормально для небольших примеров. Но по мере роста сложности ваших программ, вы, несомненно, захотите как-то автоматизировать этот процесс, чтобы упростить себе жизнь. Вот здесь и появляются make-файлы.</p>
<p>Существует три разных способа запуска ваших программ. И в этой главе, мы рассмотрим их все, так что вы сможете выбрать тот, который наиболее подходит к вашей ситуации.</p>
<p>Иногда могут происходить сбои: make-файлы могут не срабатывать, переменные окружения быть неправильными, также как и пути поиска файлов. Мы поможем вам разобраться с подобными проблемами, подсказав, что делать, если что-то пошло не так.</p>
<h2 id="6-1-shell-">6.1 Запуск и остановка Эрланг оболочки (shell)</h2>
<p>На UNIX системах (Включая Mac OS X) вы можете запустить оболочку Эрланга из командной строки консоли:</p>
<pre><code>$ erl
Erlang (BEAM) emulator version 5.5.1 [source] [async-threads:0] [hipe]
Eshell V5.5.1 (abort with ^G)
1&gt;
</code></pre><p>В системе Microsoft Windows вам надо кликнуть на иконке Эрланга.</p>
<p>Простейшим способом остановить систему является нажатие Ctrl+C (в Виндоус - Ctrl+Break) и далее - А , как в следующем примере:</p>
<pre><code>BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
a
$
</code></pre><p>Также, вместо этого, вы можете выполнить в оболочке Эрланга (или в программе) инструкцию <code>erlang:halt()</code> , что приведет к тому-же результату.</p>
<p><code>erlang:halt()</code> - это BIF которая немедленно останавливает оболочку Эрланга и именно этим способом я и пользуюсь в большинстве случаев. Но, тем не менее, в этом способе есть определенное неудобство. Если вы запустили большое приложение работающее с базами данных и просто остановите всю систему, то при следующем запуске вам придется проходить через процесс
восстановления после ошибки. Поэтому лучше останавливать систему более аккуратным способом.</p>
<p>Для контролируемой остановки, если оболочка реагирует на команды, вы можете набрать:</p>
<pre><code>1&gt; q().
ok
$
</code></pre><p>Тогда будут корректно закрыты все открытые файлы, остановлены базы данных (если они запущены) и закрыты все ОТР приложения в установленном порядке. Команда <code>q()</code> это другое имя для команды <code>init:stop()</code>.</p>
<p>Если ни один из этих методов не работает, прочитайте раздел 6.6 <em>Как выбраться из неприятностей</em>.</p>
<h2 id="6-2-">6.2. Изменение окружения</h2>
<p>Когда вы начинали программировать на Эрланге, вы, возможно, складывали все файлы и все модули в одну директорию из которой и стартовали сам Эрланг. В этом случае Эрланг без проблем мог найти ваш код. Но по мере роста сложности ваших приложений, вы наверняка захотите разделить его в управляемые куски и разместить их в различных директориях. А если вы будете включать в ваш проект внешний код, то он будет иметь свою собственную структуру директорий.</p>
<h3 id="-">Установка пути поиска для загрузки кода</h3>
<p>Система исполнения приложений Эрланг использует механизм автозагрузки кода. Чтобы он работал корректно вы должны правильно установить несколько путей поиска, чтобы находилась именно правильная версия вашего кода.</p>
<p>Механизм загрузки кода на самом деле также написан на Эрланг - подробнее мы поговорим об этом в разделе Е.4 <em>Динамическая загрузка кода</em>. И загрузка кода осуществляется , как это называют, &quot;по требованию&quot;.</p>
<p>Когда система пытается вызвать функцию в модуле, который еще не был загружен, возникает исключение, и система пытается найти файл объектного кода пропущенного модуля. Если, например, этот пропущенный модуль называется <em>myMissingModule</em>, то загрузчик кода, первым делом, будет пытаться найти файл с именем <em>MyMissingModule.beam</em> во всех директориях,
которые входят в текущий путь загрузки кода. Поиск останавливается на первом таком найденном файле и объектный код из этого файла загружается в систему.</p>
<p>Вы можете узнать текущий путь загрузки кода запустив Эрланг и набрав команду <code>code:get_path()</code>. Вот пример ее работы: </p>
<pre><code>code:get_path().
[&quot;.&quot;,
&quot;/usr/local/lib/erlang/lib/kernel-2.11.3/ebin&quot;,
&quot;/usr/local/lib/erlang/lib/stdlib-1.14.3/ebin&quot;,
&quot;/usr/local/lib/erlang/lib/xmerl-1.1/ebin&quot;,
&quot;/usr/local/lib/erlang/lib/webtool-0.8.3/ebin&quot;,
&quot;/usr/local/lib/erlang/lib/typer-0.1.0/ebin&quot;,
&quot;/usr/local/lib/erlang/lib/tv-2.1.3/ebin&quot;,
&quot;/usr/local/lib/erlang/lib/tools-2.5.3/ebin&quot;,
&quot;/usr/local/lib/erlang/lib/toolbar-1.3/ebin&quot;,
&quot;/usr/local/lib/erlang/lib/syntax_tools-1.5.2/ebin&quot;,
...]
</code></pre><p>Следующие две функции наиболее часто используются для работы с путем загрузки кода:</p>
<pre><code>@spec code:add_patha(Dir) =&gt; true | {error, bad_directory}
</code></pre><p>Добавляет новую директорию Dir в начало пути загрузки кода.</p>
<pre><code>@spec code:add_pathz(Dir) =&gt; true | {error, bad_directory}
</code></pre><p>Добавляет новую директорию Dir в конец пути загрузки кода.</p>
<p>Часто это совершенно не важно какую из них использовать. Но надо следить за случаями, когда <code>add_patha</code> и <code>add_pathz</code> приводят к различным результатам. Если вы подозреваете, что загрузился не тот модуль, то вы можете набрать <code>code:all_loaded()</code> (которая выводит все загруженные модули) или <code>code:clash()</code> (&quot;столкновение, коллизия&quot;) чтобы разобраться, что же именно произошло не так.</p>
<p>Есть, также, еще несколько процедур в модуле <code>code</code> для работы с путем загрузки, но возможно они вам никогда не понадобятся, если только вы не станете писать весьма странные системные программы.</p>
<p>Обычной практикой является размещение всех этих команд в файле <code>.erlang</code> в вашей домашней директории. Либо же вы можете запускать Эрланг командой следующего вида:</p>
<pre><code>&gt; erl -pa Dir1 -pa Dir2 ... -pz DirK1 -pz DirK2
</code></pre><p>где флаг <code>-pa DirX</code> добавляет директорию <code>DirX</code> в начало пути поиска кода, а <code>-pz DirY</code> добавляет директорию <code>DirY</code> в конец пути поиска кода.</p>
<h3 id="-">Выполнение набора команд при старте системы Эрланг</h3>
<p>Мы уже познакомились, как можно установить путь поиска кода через команды в файле <code>.erlang</code> в вашей домашней директории. Но на самом деле вы можете поместить в этот файл любые команды Эрланг и, когда вы запустите Эрланг, он первым делом прочитает и выполнит все команды из этого файла.</p>
<p>Предположим мой файл <code>.erlang</code> выглядит следующим образом:</p>
<pre><code>io:format(&quot;Running Erlang ~n&quot;).
code:add_patha(&quot;.&quot;).
code:add_pathz(&quot;/home/joe/2005/erl/lib/supported&quot;).
code:add_pathz(&quot;/home/joe/bin&quot;).
</code></pre><p>Тогда, при старте системы я увижу следующий вывод на консоль:</p>
<pre><code>$ erl
Erlang (BEAM) emulator version 5.5.1 [source] [async-threads:0] [hipe]
Running Erlang
Eshell V5.5.1 (abort with ^G)
1&gt;
</code></pre><p>Если в той директории, откуда стартует Эрланг также имеется файл <code>.erlang</code> то исполняться будет именно он, а не файл в вашей домашней директории. Таким образом вы можете настроить поведение Эрланга в зависимости от того, где он начал свою работу. Это может быть полезно для
специализированных приложений. В таком случае, вероятно, будет неплохой идеей добавить в такой файл несколько команд печати соответствующих сообщений, поскольку, в противном случае,вы можете забыть, что это локальный файл начальной настройки системы, что может привести к затруднениям в работе.</p>
<p><em>Подсказка:</em> В некоторых системах, иногда бывает не совсем очевидно, а где именно находится ваша домашняя директория. Чтобы определить, что думает Эрланг, где она находится, сделайте следующее:</p>
<pre><code>1&gt; init:get_argument(home).
{ok,[[&quot;/home/joe&quot;]]}
</code></pre><p>Откуда мы можем понять, что Эрланг думает, что нашей домашней директорией является <code>/home/joe</code>.</p>
<h2 id="6-3-">6.3. Различные способы запустить вашу программу</h2>
<p>Программы Эрланга хранятся в модулях. как только вы написали вашу программу вы должны ее скомпилировать перед тем как запускать ее. Однако вы можете запустить вашу программу без компиляции запустив <code>escript</code>.</p>
<p>В следующих разделах мы покажем как скомпилировать и запустить несколько программ разными способами. Программы немного различаются, равно как и способы их запуска и остановки.</p>
<p>Первая программа <code>hello.erl</code> просто печатает фразу &quot;Hello world!&quot;. Она не будет запускать или останавливать систему Эрланг и ей не нужен доступ к аргументам в командной строке. Но наша вторая программа <code>fac</code> , наоборот будет нуждаться в доступе к параметру командной строки при ее запуске.</p>
<p>Вот наша простейшая программа, сохраненная в файле hello.erl. Она печатает строку &quot;Hello World&quot; с последующим переходом на новую строку (символ <code>~n</code> интерпретируется как новая строка в модулях Эрланга <code>io</code> и <code>io_lib</code>).</p>
<p>Скачать <a href="http://media.pragprog.com/titles/jaerlang/code/hello.erl">hello.erl</a></p>
<pre><code>-module(hello).
-export([start/0]).

start() -&gt;
  io:format(&quot;Hello world~n&quot;).
</code></pre><p>Давайте скомпилируем и запустим эту программу тремя разными способами.</p>
<h3 id="-shell-">Компиляция и запуск в оболочке Эрланг (shell)</h3>
<pre><code>$ erl
Erlang (BEAM) emulator version 5.5.1 [source] [async-threads:0] [hipe]

Eshell V5.5.1 (abort with ^G)
1&gt; c(hello).
{ok,hello}
2&gt; hello:start().
Hello world
ok
</code></pre><h3 id="-">Компиляция и запуск из командной строки</h3>
<pre><code>$ erlc hello.erl
$ erl -noshell -s hello start -s init stop
Hello world
$
</code></pre><blockquote>
<h3 id="-">Быстрое исполнение</h3>
<p>Часто возникает необходимость выполнить некоторую функцию Эрланга из командной строки операционной системы. В этом случае ключ <code>-eval</code> с аргументом бывает очень полезен для такого быстрого исполнения.</p>
<p>Приведем пример:</p>
<p><code>erl -eval &#39;io:format(&quot;Memory: ~p~n&quot; , [erlang:memory(total)]).&#39; -noshell -s init stop</code></p>
</blockquote>
<p><em>Пользователи Microsoft Windows:</em> Чтобы это сработало, вам надо либо добавить в переменную PATH директорию содержащую исполняемый код системы Эрланг, либо вызывать erlc и erl полным именем (включая двойные кавычки).</p>
<p>Например:</p>
<pre><code>&quot;C:\Program Files\erl5.5.3\bin\erlc.exe&quot; hello.erl
..
</code></pre><p>Первая строка приведенная выше <code>erlc hello.erl</code> компилирует файл <code>hello.erl</code> в файл объектного кода <code>hello.beam</code>. Вторая команда возможна в трех различных вариантах:</p>
<pre><code>-noshell
</code></pre><p>Запускает систему Эрланг без интерактивной оболочки (то есть вы не увидите стандартной надписи при запуске Эрланга).</p>
<pre><code>-s hello start
</code></pre><p>Запускается функция <code>hello:start()</code>.</p>
<p><em>Примечание:</em> При использовании <code>-s Module</code> сам <code>Module</code> должен быть уже скомпилированным.</p>
<pre><code>-s init stop
</code></pre><p>Когда закончится исполнение <code>apply(hello, start, [])</code> система автоматически выполнит функцию <code>init:stop()</code>.</p>
<p>Команда <code>erl -noshell ...</code> может использоваться в командных файлах интерпретатора команд ОС <em>(shell scripts)</em>, так что типичным случаем является создание командных файлов, которые устанавливают пути поиска (с помощью <code>-pa Directory</code>) и запускают программу.</p>
<p>В нашем примере мы использовали две <code>-s</code> команды. Число их в командной строке не ограничено. Каждая <code>-s</code> команда будет выполнена с помощью функции <code>apply</code> , а когда она закончится, начнется выполнение следующей команды.</p>
<p>Вот пример запуска <code>hello.erl</code></p>
<p>Скачать <a href="http://media.pragprog.com/titles/jaerlang/code/hello.sh">hello.sh</a></p>
<pre><code>#!/bin/sh
erl -noshell -pa /home/joe/2006/book/JAERANG/Book/code\
             -s hello start -s init stop
</code></pre><p><em>Примечание:</em> Этот скрипт нуждается в абсолютном пути до директории, где находится файл <code>hello.beam</code> . Так что, хотя он и работает на моей машине, вам придется подредактировать его, чтобы он работал на вашей.</p>
<p>Чтобы запустить этот скрипт вы должны установить ему соответственно атрибуты командой <code>chmod</code> (только один раз) и тогда, будет можно его запускать:</p>
<pre><code>$ chmod u+x hello.sh
$ ./hello.sh
Hello world
$
</code></pre><p><em>Примечание:</em> В Microsoft Windows, прием <code>#!</code> не работает. Там придется создать <code>.bat</code> файл и использовать полный путь к исполняемой части системы Эрланг, если переменная <code>PATH</code> для нее не установлена соответственно.</p>
<p>Типичный скрипт-файл для Microsoft Windows может выглядеть приблизительно так:</p>
<p>Скачать <a href="http://media.pragprog.com/titles/jaerlang/code/hello.bat">hello.bat</a></p>
<pre><code>&quot;C:\Program Files\erl5.5.3\bin\erl.exe&quot; -noshell -s hello start -s init stop
</code></pre><h3 id="-escript">Запуск через Escript</h3>
<p>Используя <code>escript</code> вы можете запускать свои программы именно как скрипты, без их предварительной компиляции.</p>
<p><em>Предупреждение:</em> <code>escript</code> входит в Эрланг начиная с версии R11B-4 и далее. Если у вас более ранняя версия Эрланга, то вы должны ее обновить до последней версии системы Эрланг.</p>
<p>Для запуска <code>hello</code> как скрипта, мы создадим следующий файл: </p>
<p>Скачать <a href="http://media.pragprog.com/titles/jaerlang/code/hello">hello</a></p>
<pre><code>#!/usr/bin/env escript
main(_) -&gt;
io:format(&quot;Hello world ~n&quot; ).
</code></pre><blockquote>
<h3 id="-">Экспорт функций во время разработки</h3>
<p>Когда вы разрабатываете код, вам может быть немного неудобно все время возвращаться к разделу объявления экспорта функций, только для того, чтобы была возможность запустить их в оболочке Эрланг.</p>
<p>Специальная декларация для компилятора <code>-compile(export_all)</code> указывает ему экспортировать все функции в модуле. Это существенно упрощает жизнь пока вы разрабатываете код.</p>
<p>Когда вы закончили разработку кода в этом модуле, вы должны закомментировать декларацию <code>export_all</code> и добавить более точные декларации по экспорту функций. На это есть две причины. Во-первых, когда вы придете в следующий раз читать ваш код, вы будете знать, что только важные функции были проэкспортированы наружу, а остальные функции не могут быть вызваны снаружи, так что вы можете их менять, как вам это нужно, сохраняя лишь их интерфейс к проэкспортированным функциям. А во-вторых, компилятор может произвести гораздо более лучший код, когда он точно знает, какие именно функции проэкспортированы из данного модуля.</p>
</blockquote>
<p>На UNIX системах мы можем запустить этот файл немедленно и без всякой компиляции:</p>
<pre><code>chmod u+x hello
$ ./hello
Hello world
$
</code></pre><p><em>Примечание:</em> Параметры данного файла должны быть переведены в исполнимые (что в UNIX достигается командой <code>chmod u+x File</code>), что нужно сделать только один раз, а не каждый раз при запуске программы.</p>
<h3 id="-">Программы с аргументами в командной строке</h3>
<p>&quot;Hello world&quot; не имеет никаких аргументов. Давайте повторим наше упражнение для программы, которая вычисляет факториалы. Ей потребуется один аргумент.</p>
<p>Во-первых, вот ее код</p>
<p>Скачать <a href="http://media.pragprog.com/titles/jaerlang/code/fac.erl">fac.erl</a></p>
<pre><code>-module(fac).
-export([fac/1]).

fac(0) -&gt; 1;
fac(N) -&gt; N*fac(N-1).
</code></pre><p>Мы можем скомпилировать <code>fac.erl</code> и запустить его в оболочке Эрланга следующим образом:</p>
<pre><code>$ erl
Erlang (BEAM) emulator version 5.5.1 [source] [async-threads:0] [hipe]

Eshell V5.5.1 (abort with ^G)
1&gt; c(fac).
{ok,fac}
2&gt; fac:fac(25).
15511210043330985984000000
</code></pre><p>Если же мы хотим запускать эту программу из командной строки, то нам надо ее модифицировать, чтобы она воспринимала оттуда параметр :</p>
<p>Скачать <a href="http://media.pragprog.com/titles/jaerlang/code/fac1.erl">fac1.erl</a></p>
<pre><code>-module(fac1).
-export([main/1]).

main([A]) -&gt;
    I = list_to_integer(atom_to_list(A)),
    F = fac(I),
    io:format(&quot;factorial ~w = ~w~n&quot; ,[I, F]),
    init:stop().

fac(0) -&gt; 1;
fac(N) -&gt; N*fac(N-1).
</code></pre><p>Теперь мы можем ее скомпилировать и запустить:</p>
<pre><code>$ erlc fac1.erl
$ erl -noshell -s fac1 main 25
factorial 25 = 15511210043330985984000000
</code></pre><p><em>Примечание:</em> То что функция называется <code>main</code> - это не важно. Она может называться как угодно. Важно только чтобы ее имя и имя функции в командной строке совпадали.</p>
<p>Наконец, мы можем запустить ее как скрипт:</p>
<p><a href="http://media.pragprog.com/titles/jaerlang/code/factorial">Скачать factorial</a></p>
<pre><code>#!/usr/bin/env escript

main([A]) -&gt;
  I = list_to_integer(A),
  F = fac(I),
  io:format(&quot;factorial ~w = ~w ~n&quot; ,[I, F]).

fac(0) -&gt; 1;

fac(N) -&gt;
  N * fac(N-1).
</code></pre><p>Компиляция здесь не нужна, просто запускаем его:</p>
<pre><code>$ ./factorial 25
factorial 25 = 15511210043330985984000000
$
</code></pre><h2 id="6-4-make-">6.4. автоматическая компиляция в make-файлах</h2>
<p>Когда я пишу большую программу, я хочу автоматизировать этот процесс настолько, насколько это вообще возможно. На это есть две причины. Во-первых, в долгосрочной перспективе, это спасает от набивания опять и опять одних и тех-же команд во время многократного тестирования моей
программы из множества строк и я не хочу чтобы мои пальцы у меня отвалились от всего этого.</p>
<p>Во-вторых, я часто откладываю текущий проект и вынужден поработать над чем-то еще. Могут пройти месяцы, прежде чем я вернусь к отложенному проекту и я совершенно забываю, как надо обрабатывать в нем код, что не оставляет мало шансов на его спасение!</p>
<p><code>make</code> - это утилита, которая автоматизирует мою работу. Я использую ее для компиляции и распределения моего Эрланг - кода. Большинство моих make-файлов чрезвычайно просты и у меня есть для них готовые шаблоны, которые решают абсолютное большинство моих проблем.</p>
<p>Я не буду рассказывать о make-файлах в общем (см., например: <a href="http://ru.wikipedia.org/wiki/Make">http://ru.wikipedia.org/wiki/Make</a>). Вместо этого я покажу их форму, которая кажется мне полезной для компиляции Эрланг программ. В частности, мы рассмотрим make-файлы, прилагаемые к данной книге, что значит, что вы будете понимать их и уметь писать, на их основе, собственные маке-файлы.</p>
<h3 id="-">Шаблон маке-файла</h3>
<p>Вот шаблон, на основе которого я создаю большинство своих make-файлов</p>
<p>Скачать <a href="http://media.pragprog.com/titles/jaerlang/code/Makefile.template">Makefile.template</a></p>
<pre><code># Эти строки не меняйте
.SUFFIXES: .erl .beam .yrl

.erl.beam:
  erlc -W $&lt;

.yrl.erl:
  erlc -W $&lt;

ERL = erl -boot start_clean

# Здесь указывается список модулей которые будем компилировать
# Если модули не помещаются в одну строку можно добавить символ \
# в конце строки и продолжить на следующей строке

# Отредактируйте строки которые находятся ниже

MODS = module1 module2 \
       module3 ... special1 ...\
       ...
       moduleN

# The first target in any makefile is the default target.
# If you just type &quot;make&quot; then &quot;make all&quot; is assumed (because
# &quot;all&quot; is the first target in this makefile)

all: compile

compile: ${MODS:%=%.beam} subdirs

## Специальный метод компиляции

special1.beam: special1.erl
    ${ERL} -Dflag1 -W0 special1.erl

## run an application from the makefile

application1: compile
    ${ERL} -pa Dir1 -s application1 start Arg1 Arg2

# the subdirs target compiles any code in
# sub-directories

subdirs:
    cd dir1; make
    cd dir2; make
    ...

# remove all the code

clean:
    rm -rf *.beam erl_crash.dump
    cd dir1; make clean
    cd dir2; make clean
</code></pre><p>Данный make-файл начинается с правил компиляции модулей Эрланга и файлов с расширением <code>.yrl</code> (эти файлы содержат определения для программы Эрланг парсер-генератор)</p>
<p>Важной частью make-файла является следующая строка:</p>
<pre><code>MODS = module1 module2
</code></pre><p>Это список всех Эрланг-модулей, которые я хочу скомпилировать.</p>
<p>Каждый модуль из строки MODS будет скомпилирован командой <code>erlc Mod.erl</code>. Некоторые модули могут требовать специального обхождения с ними (например модуль <code>special1</code> в файле-шаблоне), поэтому для них есть отдельное правило обработки.</p>
<p>Внутри make-файла имеется много <em>целей</em>. Цель - это символьно-числовая строка, начинающаяся в первой позиции строки make-файла и оканчивающаяся двоеточием <code>:</code>. В нашем make-файле шаблоне <code>all</code>, <code>compile</code> и <code>special.beam</code> все являются целями. Чтобы выполнить make-файл вы даете следующую команду в консоли:</p>
<pre><code>$ make [Target]
</code></pre><p>Параметр <em>Target</em> - не обязательный. Если его нет, тогда подразумевается первая цель в файле. В нашем примере - это цель <code>all</code>, если другой цели не было задано в командной строке.</p>
<p>Если я хочу перестроить мою программу и запустить <code>application1</code> , тогда я отдам команду <code>make application1</code>. Если я хочу чтобы это было поведением по умолчанию, вызываемым только по команде <code>make</code>, то мне надо передвинуть строки определяющие цель <code>application1</code> так, чтобы они стали первой целью в make-файле.</p>
<p>Цель <code>clean</code> удаляет все скомпилированные объектные коды Эрланга и файл <code>erl_crush.dump</code>. Этот файл содержит информацию, которая может помочь отладить ваше приложение. Более детально данная тема рассмотрена в разделе 6.10 <em>Аварийный сброс системы (Crush Dump)</em>.</p>
<h3 id="-make-">Специализация шаблона Make-файла</h3>
<p>Я не сторонник беспорядка в моих программах, поэтому я обычно начинаю с шаблона make-файла и удаляю из него все строки не имеющие отношения к моему приложению. Это дает мне make-файл который короче и гораздо более понятный при его прочтении. Но, с другой стороны, вы можете иметь обобщенный, универсальный make-файл, включаемый во все make-файлы, поведение которого определяется их конкретными, специфическими переменными.</p>
<p>Результатом моего, вышеуказанного, процесса, может быть, например, нижеуказанный маке-файл:</p>
<pre><code>.SUFFIXES: .erl .beam

.erl.beam:
    erlc -W $&lt;

ERL = erl -boot start_clean

MODS = module1 module2 module3

all: compile
    ${ERL} -pa &#39;/home/joe/.../this/dir&#39; -s module1 start

compile:
    ${MODS:%=%.beam}

clean:
    rm -rf *.beam erl_crash.dump
</code></pre><h2 id="6-5-">6.5. Редактирование командами в оболочке Эрланга</h2>
<p>Оболочка Эрланга содержит встроенный строковый редактор. Его команды являются подмножеством команд редактирования строчек используемых в популярном редакторе emacs. Предыдущие строки могут быть вызваны и отредактированы несколькими командными символами. Они приведены далее
(учтите что <em>^Key</em> означает, что вы должны нажать <em>Ctrl+Key</em>):</p>
<table>
<thead>
<tr>
<th>Команда</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td>^A</td>
<td>Начало строки</td>
</tr>
<tr>
<td>^E</td>
<td>Конец строки</td>
</tr>
<tr>
<td>^F или стрелка вправо</td>
<td>Вперед на символ</td>
</tr>
<tr>
<td>^B или стрелка влево</td>
<td>Назад на символ</td>
</tr>
<tr>
<td>^P или стрелка вверх</td>
<td>Предыдущая строка</td>
</tr>
<tr>
<td>^N или стрелка вниз</td>
<td>Следующая строка</td>
</tr>
<tr>
<td>^T</td>
<td>Поменять последние два символа</td>
</tr>
<tr>
<td>Табуляция</td>
<td>Попытаться дописать имя текущего модуля или функции</td>
</tr>
</tbody>
</table>
<h2 id="6-6-">6.6. Как выбраться из неприятностей</h2>
<p>Эрланг иногда бывает трудно остановить. Перечислим здесь некоторые
причины этого:</p>
<ul>
<li>Оболочка Эрланга не отвечает</li>
<li>Обработка команды <em>Ctrl+C</em> была выключена</li>
<li>Эрланг был запущен с флагом <code>-detached</code> так, что вы можете не знать, что он работает</li>
<li>Эрланг был запущен с опцией <code>-heart Cmd</code>. Эта опция заставляет мониторинг процессов ОС следить за ОС-процессом Эрланга. И если Эрланг-процесс в ОС умирает, то выполнить команду <code>Cmd</code>. Часто, при этом, <code>Cmd</code> просто перезапускает систему Эрланг. Это один из трюков, который используется для создания отказоустойчивых узлов Эрланга. Если вдруг слетит сам Эрланг (что, вообще говоря, не должно происходить), он просто будет перезапущен. Хитростью при остановке Эрланга теперь является найти сначала тот замеряющий пульс Эрланг-процесс (используйте <code>ps</code> на UNIX-подобных машинах и Менеджер Задач (Task Manager) в Microsoft Windows и убить его перед тем как убивать процесс Эрланга в данной ОС.</li>
<li>Что-то может пойти совсем не так и оставить вас с непривязанным
зомби-процессом Эрланга.</li>
</ul>
<h2 id="6-7-">6.7. Когда что-то пошло не так</h2>
<p>В этом разделе перечисляются некоторые общие проблемы и варианты их решения.</p>
<h3 id="-">Неопределенный (Потерянный) код</h3>
<p>Если вы пытаетесь запустить код в модуле, который загрузчик не может найти (поскольку заданный ему путь поиска некорректен) вы встретитесь с <code>undef</code> (неопределен) - сообщением об ошибке. Вот его пример:</p>
<pre><code>1&gt; glurk:oops(1,23).
** exited: {undef,[{glurk,oops,[1,23]},
{erl_eval,do_apply,5},
{shell,exprs,6},
{shell,eval_loop,3}]}
</code></pre><p>На самом деле, здесь просто не существует модуля с именем <code>glurk</code>, но не это важно. Вы должны сконцентрироваться на рассмотрении сообщения об ошибке. Оно говорит нам, что система Эрланг пыталась вызвать функцию <code>oops</code> с аргументами 1 и 23 из модуля <code>glurk</code>. Следовательно, возможны четыре варианта, того что произошло при этом.</p>
<ul>
<li>Возможно действительно не существует модуль <code>glurk</code>.</li>
<li>Возможно его имя было указано слегка неверно (с опечаткой).</li>
</ul>
<blockquote>
<h3 id="-">Кто нибудь видел мою точку с запятой?</h3>
<p>Если вы забыли поставить точку с запятой между вариантами вызова вашей функции, или поставили туда точку, вместо этого, то у вас будут большие неприятности.</p>
<p>Если вы определили функцию <code>foo/2</code> в строке 1234 своего модуля <code>bar</code> и поставили точку вместо точки с запятой, компилятор скажет вам:</p>
<p><code>bar.erl:1234 function foo/2 already defined.</code></p>
<p>Не делайте этого. Убедитесь, что ваши варианты функции всегда отделены
друг от друга точкой с запятой.</p>
</blockquote>
<ul>
<li>Модуль <code>glurk</code> существует, но он не был скомпилирован. Система ищет файл с именем <code>glurk.beam</code> в директориях указанных ей в пути поиска кода.</li>
<li>Модуль <code>glurk</code> существует и он был откомпилирован, но директория, в которой находится <code>glurk.beam</code> не входит в путь поиска кода. Чтобы исправить эту ошибку вам, возможно, потребуется изменить путь поиска кода. Как это сделать мы рассмотрим чуть позже.</li>
<li>Существует несколько версий <code>glurk</code> в директориях поиска кода и мы выбрали не тот что нужно. Это редкая ошибка, но такое тоже возможно. Если вы подозреваете, что произошло именно это вы можете запустить функцию <code>code:clash()</code>, которая сообщает обо всех повторяющихся модулях в директориях входящих в путь поиска кода.</li>
</ul>
<h3 id="-">Мой маке-файл ничего не создает</h3>
<p><em>Что может, вообще, случиться с маке-файлом?</em> Ну, на самом деле, много чего. Но эта книга не про то как с ними работать, так что я ограничусь только самыми распространенными ошибками, связанными с ними.</p>
<p>Вот две самые частые ошибки с которыми я сталкивался:</p>
<ul>
<li><em>Пробелы в маке-файле:</em> Make-файлы крайне привередливы. Хотя вы и не можете их видеть, но все, связанные с предыдущей, строки должны начинаться с символа табуляции (за исключением продолжения строк, где <em>на предыдущей строке</em> должен стоять в конце символ <code>\</code>). Если вдруг там окажутся пробелы, то make-файл очень сильно будет смущен и вы отправитесь на поиски ошибки.</li>
<li><p><em>Пропущенный Эрланг-файл:</em> Если отсутствует один из модулей указанный в цели make-файла <code>MODS</code>, вы получите сообщение об ошибке. Для примера предположим, что <code>MODS</code> содержит модуль с именем <code>glurk</code>, но файла с именем <code>glurk.erl</code> нет в директории содержащей код. В этом случае маке выдаст следующую ошибку:</p>
<pre><code>$ make
make: *** No rule to make target ‘glurk.beam&#39;,
      needed by ‘compile&#39;. Stop.
</code></pre></li>
</ul>
<p>Возможно, также, что такой модуль присутствует, но, просто, его имя было указано некорректно в make-файле.</p>
<h3 id="-">Оболочка Эрланга не отвечает</h3>
<p>Если оболочка не отвечает на команды, то могла произойти масса причин для этого. Сам процесс оболочки мог погибнуть, или вы могли запустить команду, которая никогда не закончится. Вы также могли забыть закрывающие кавычки или забыть набрать точка-возврат-каретки в конце вашей команды.</p>
<p>Но независимо от причин, вы можете прервать вашу оболочку Эрланга нажатием клавиш <code>Ctrl+G</code> и проследовать за следующим примером:</p>
<pre><code>1&gt;receive foo -&gt; true end.
^G 
User switch command

--&gt; h
    c [nn] - connect to job`
    i [nn] - interrupt job
    k [nn] - kill job
    j - list all jobs
    s - start local shell
    r [node] - start remote shell
    q - quit erlang
    ? | h - this message`

--&gt; j
    1* {shell,start,[init]}

--&gt; s
--&gt; j
    1 {shell,start,[init]}
    2* {shell,start,[]}

--&gt; c 2
    Eshell V5.5.1 (abort with ^G)
    1&gt; init:stop().
    ok
    2&gt; $
</code></pre><ol>
<li><p>Здесь я сказал оболочке принять сообщение <code>foo</code>. Но поскольку никто никогда не собирается посылать оболочке это сообщение, она входит в бесконечное ожидание этого сообщения. Я нажимаю <code>Ctrl+G</code>.</p>
</li>
<li><p>Система входит в режим контроля работ ( <em>Job Control Mode</em> или <em>JCL</em>). Тут я никогда не могу вспомнить его команды, поэтому я набираю <code>h</code> чтобы вызвать подсказку.</p>
</li>
<li><p>Я набираю <code>j</code> чтобы вывести весь список работ. Работа номер 1 отмечена символом звездочка, что означает, что это оболочка Эрланга по умолчанию. Все прочие команды используют именно ее, если только им не указан параметр вида <code>[nn]</code>.</p>
</li>
<li><p>Я набираю <code>s</code> чтобы запустить новую оболочку и опять набираю <code>j</code>. На этот раз я вижу что уже есть две оболочки с номерами <em>1</em> и <em>2</em> и оболочка с номером <em>2</em> стала оболочкой по умолчанию.</p>
</li>
<li><p>Я набираю <em>2</em> что подсоединяет меня к только что запущенной оболочке <em>2</em>, в которой я останавливаю систему Эрланг.</p>
</li>
</ol>
<p>Как видите у вас может быть множество оболочек в системе Эрланг, в которых можно набирать команды и переключаться между ними нажимая <code>Ctrl+G</code>. Вы даже можете запустить оболочку на удаленном Эрланг-узле с помощью команды <code>r</code> с соответствующим параметром.</p>
<h2 id="6-8-">6.8. Вызов помощи</h2>
<p>В UNIX системах это делается так:</p>
<pre><code>$ erl -man erl
NAME
erl - The Erlang Emulator

DESCRIPTION
The erl program starts the Erlang runtime system.
The exact details (e.g. whether erl is a script
or a program and which other programs it calls) are system-dependent.
...
</code></pre><p>Вы также можете получить справку по отдельным модулям:</p>
<pre><code>$ erl -man lists
MODULE
lists - List Processing Functions

DESCRIPTION
This module contains functions for list processing.
The functions are organized in two groups:
...
</code></pre><p><em>Примечание:</em> На UNIX системах страницы справки по умолчанию не установлены. Если команда <code>erl -man</code> не работает, то вам нужны страницы справки по Эрланг. Все они имеются в сжатом архиве по адресу <a href="http://www.erlang.org/download.html">http://www.erlang.org/download.html</a>. Справочные страницы Эрланга должны
быть разархивированы в корневой директории установки Эрланга (обычно это <code>/usr/local/lib/erlang</code>).</p>
<p>Документацию по Эрланг также можно загрузить в виде связанного множества HTML файлов. В ОС Microsoft Windows HTML документация устанавливается по умолчанию и доступна в разделе Эрланг в меню Старт данной ОС.</p>
<h2 id="6-9-">6.9 Настройка окружения</h2>
<p>Оболочка Эрланга имеет множество встроенных команд. Вы можете прочитать о них всех с помощью команды оболочки <code>help().</code>:</p>
<pre><code>1&gt; help().
** shell internal commands **
b() -- display all variable bindings
e(N) -- repeat the expression in query &lt;N&gt;
f() -- forget all variable bindings
f(X) -- forget the binding of variable X
h() -- history
...
</code></pre><p>Все эти команды определены в модуле <code>shell_default</code>.</p>
<p>Если вы хотите определить для оболочки свои собственные команды, просто создайте модуль с именем <code>user_default</code>. Например: </p>
<p>Скачать <a href="http://media.pragprog.com/titles/jaerlang/code/user_default.erl">user_default.erl</a></p>
<pre><code>-module(user_default).
-compile(export_all).

hello() -&gt;
  &quot;Hello Joe how are you?&quot;.

away(Time) -&gt;
  io:format(&quot;Joe is away and will be back in ~w minutes ~n&quot;, [Time]).
</code></pre><p>Как только он будет скомпилирован и размещен где-то на пути вашего поиска кода, вы сможете вызывать любую его функцию без указания имени самого модуля:</p>
<pre><code>1&gt; hello().
&quot;Hello Joe how are you?&quot;
2&gt; away(10).
Joe is away and will be back in 10 minutes
ok
</code></pre><h2 id="6-10-crash-dump-">6.10 Аварийный сброс данных системы (Crash Dump)</h2>
<p>Если система Эрланг падает, то она оставляет после этого файл с именем <code>erl-crash.dump</code>. Содержимое этого файла может помочь вам разобраться, что же именно пошло не так. Чтобы его проанализировать есть анализатор аварий основанный на веб-интерфейсе. Чтобы его запустить наберите следующую команду:</p>
<pre><code>1&gt; webtool:start().**
WebTool is available at http://localhost:8888/
Or http://127.0.0.1:8888/
{ok,&lt;0.34.0&gt;}
</code></pre><p>Потом укажите вашему браузеру адрес <a href="http://localhost:8888/">http://localhost:8888/</a> и вы сможете с удовольствием покопаться в журнале ошибки <code>(error log)</code>.</p>
<p>Итак, мы закончили рассмотрение низко-уровневых механизмов системы Эрланг и теперь можем перейти к параллельным программам. С этого момента вы вступаете на незнакомую территорию, но именно тут-то и начинается самое веселье.</p>
<ol>
<li><p>Я не знаю можно ли запустить escript в Microsoft Windows. Если кто-то знает, как это сделать, напишите мне письмо об этом и я добавлю эту информацию в книгу.</p>
</li>
<li><p>Эрланговский парсер-генератор называется <code>yecc</code> (Эрланговская версия <code>yacc</code> - от &quot;yet another compiler compiler&quot; (еще один компилятор компиляторов)) Смотри руководство по нему в Интернете по адресу: <a href="http://www.erlang.org/contrib/parser_tutorial-1.0.tgz">http://www.erlang.org/contrib/parser_tutorial-1.0.tgz</a>.</p>
</li>
</ol>

		</div>
		
		
		<!-- pagination -->
		<nav>

	<ul class="pager">
  <li class="previous"><a href="http://erlangbook.tk/05" title="Previous Post: Глава 5. Расширенное последовательное программирование" class="navlinks-prev"><span class="glyphicon glyphicon-arrow-left" aria-hidden="true"></span> Глава 5. Расширенное последовательное программирование</a></li>
  <li class="next"><a href="http://erlangbook.tk/07" title="Next Post: Глава 7. Параллельность" class="navlinks-next">Глава 7. Параллельность <span class="glyphicon glyphicon-arrow-right" aria-hidden="true"></span></a></li>
</ul>

</nav>

		
		
		<!-- footer -->
		<footer>
			<div class="container" >
			<div class="row" >
			<div class="col-sm-1">
<!--LiveInternet logo--><a href="//www.liveinternet.ru/click"
target="_blank"><img src="//counter.yadro.ru/logo?52.6"
title="LiveInternet: �������� ����� ���������� � ����������� �� 24 ����"
alt="" border="0" width="88" height="31"/></a><!--/LiveInternet-->
</div>

			<div class="col-sm-11">
<script language="JavaScript" src="http://r1.wmlink.ru/?id=422948"></script>
</div>

			</div>
			</div>
			
			<p>
	&copy; 2015 <a href="http://erlangbook.tk">erlangbook.tk</a>
</p>

		</footer>
	</div>

	<!-- Bootstrap core JavaScript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<!-- Latest compiled and minified JavaScript -->
	<script src="http://erlangbook.tk/js/bootstrap.min.js"></script>
	<script src="http://erlangbook.tk/js/docs.js"></script>

<!--bootstrap material design-->
        <script src="http://erlangbook.tk/js/ripples.min.js"></script>
        <script src="http://erlangbook.tk/js/material.min.js"></script>
        <script>
            $(document).ready(function() {
                $.material.init();
            });
        </script>

</body>
</html>