<!DOCTYPE html>
<html lang="ru">
<head>
	
	<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<meta name="keywords" content="эрланг, erlang, сокеты, программирование сокетов, сообщение, установка соединения, соединение">


<meta name="description" content="Модель программирования Эрланга — это то как мы, на самом деле, думаем и взаимодействуем. Джо Армстронг">

<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="http://bootstrap-3.ru/assets/ico/favicon.ico">

<title>Глава 14. Программирование с сокетами</title>

<!-- Bootstrap core CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">

<!--bootstrap material design-->
        <link href="/css/ripples.min.css" rel="stylesheet">
        <link href="/css/material-wfont.min.css" rel="stylesheet">

<!-- Custom styles for this template -->
<link href="/css/theme.css" rel="stylesheet">
<link href="/css/pygments.css" rel="stylesheet">

<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

	
</head>
<body>
	
	<!--LiveInternet counter--><script type="text/javascript"><!--
new Image().src = "//counter.yadro.ru/hit?r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";h"+escape(document.title.substring(0,80))+
";"+Math.random();//--></script><!--/LiveInternet-->


	
	<div class="container">
		<!-- main menu-->
		<menu>
			<div class="container" role="navigation">
<ul class="nav nav-pills nav-justified">

	<li role="presentation" >
		<a class="menu_item" style="color:white" href="http://erlangbook.tk/index.html">Главная</a>
	</li>

	<li role="presentation" >
		<a class="menu_item" style="color:white" href="http://erlangbook.tk/chapters.html">Оглавление</a>
	</li>

	<li role="presentation" >
		<a class="menu_item" style="color:white" href="http://erlangbook.tk/download.html">Скачать книгу</a>
	</li>

	<li role="presentation" >
		<a class="menu_item" style="color:white" href="http://erlangbook.tk/about_translation.html">О переводе</a>
	</li>

</ul>
</div>

		</menu>
		
		
		<!-- page content -->
		<div class="jumbotron" >
			<h1 class="cover-heading">Глава 14. Программирование с сокетами</h1>
			<p>Наиболее интересные программы, которые я пишу так или иначе включают сокеты. Сокет – это конечная точка соединения, которая позволяет взаимодействовать машинам по Интернет, используя Internet Protocol(IP). В этом разделе мы сконцентрируем свое внимание на двух протоколах интернета: Transmission Control Protocol(TCP) и User Datagram Protocol(UDP) </p>
<p>UDP позволяет приложениям посыласть друг другу короткие сообщения(называемые дейтаграммами), но этот протокол не гарантирует доставку сообщений. Дейтаграммы могут прийти в неправильном порядке. С дргой стороны – TCP, предоставляет надежный поток байтов, которые доставляются в правильном порядке на протяженни всего соединения. </p>
<p>Почему программирование с использованием сокетов увлекательно? Потому что это позволяет приложениям взаимодействовать по интернет с другими машинами, что имеет гораздо больший потенциал, чем выполнение локальных операций. </p>
<p>Существуют две основные библиотеки для программирования на сокетах – это <code>get_tcp</code>, для программирования TCP соединений, и <code>gen_udp</code> для UDP соединений </p>
<p>В этой главе мы увидим как клиент и сервер используют TCP и UDP сокеты. Мы пройдем через различные формы серверов: параллельные, последовательные, блокирующий и неблокирующие, и увидим, как сделать traﬃc-shaping приложения, которые контроллируют поток данных к программам. </p>
<h2 id="14-1-tcp">14.1 Использование TCP</h2>
<p>Мы начнем наше путешествие в программирование сокетов с рассмотрения простой TCP программы, которая получает данные с сервера. После этого мы напишем простой последовательный TCP сервер, и покажем, как он может быть распараллелен для обработки множества параллельных сессий. </p>
<h3 id="14-1-1-">14.1.1 Получение данных с сервера</h3>
<p>Начнем с написания небольшой функции (1)(2), которая использует TCP сокет для получения HTML страницы с <a href="http://www.google.com">http://www.google.com</a>:</p>
<p>Загрузить <a href="http://media.pragprog.com/titles/jaerlang/code/socket_examples.erl">socket_examples.erl</a></p>
<pre><code>nano_get_url() -&gt; 
    nano_get_url(&quot;www.google.com&quot;).

nano_get_url(Host) -&gt; 
    {ok,Socket} = gen_tcp:connect(Host,80,[binary, {packet, 0}]), 
    ok = gen_tcp:send(Socket, &quot;GET / HTTP/1.0\r\n\r\n&quot;), 
    receive_data(Socket, []). 
receive_data(Socket, SoFar) -&gt; 
    receive {tcp,Socket,Bin} -&gt; 
        receive_data(Socket, [Bin|SoFar]); 
{tcp_closed,Socket} -&gt; list_to_binary(reverse(SoFar))
end. 
</code></pre><p><em>(1) стандартная библиотечная функция, которая делает то же самое называется http:request(Url). Но мы хотим показать, как это можно сделать средствами библиотеки gen_tcp.</em></p>
<p><em>(2) В современной версии документации нету библиотеки http, зато есть httpc</em></p>
<h4 id="-">Как это работает?</h4>
<ol>
<li><p>Мы открываем TCP сокет с адресом <a href="http://google.com">http://google.com</a> на 80 порту, при помощи gen_tcp:connect. Аргумент binary в функции connect говорит системе открыть сокет в двоичном режиме и доставлять все данные приложению как бинарные. {packet,0} в контексте TCP означает, что данные доставляются непосредственно приложению, в немодифицированной форме. </p>
</li>
<li><p>Мы вызываем get_tcp:send и посылаем сообщение GET / HTTP/1.0\r\n\r\n в сокет. Затем мы ожидаем ответа. Ответ не придет весь одним пакетом, он прийдет фрагментами. Процесс, открывший сокет, или контроллирующий его будет получать фрагменты, как последовательность сообщений. </p>
</li>
<li><p>Мы принимаем сообщение вида {tcp,Socket,Bin}. Третий аргумент этого кортежа – это двоичные данные.Так получилось потому, что мы открыли сокет в бинарном режиме. Это сообщение — один из фрагментов, которые веб-сервер посылает нам. Мы получили один фрагмент, добавили его в список фрагментов, и затем ожидаем следующий фрагмент. </p>
</li>
<li><p>Мы получаем {tcp_closed,Socket}. Это произошло потому, что сервер закончил отправку данных. (3)</p>
</li>
<li><p>Когда все фрагменты пришли,нам необходит реверсировать список, поскольку мы сохраняли фрагменты в неправильном порядке. </p>
</li>
</ol>
<p>Давайте проверим, что это работает: </p>
<pre><code>1&gt; B = socket_examples:nano_get_url(). 
&lt;&lt;&quot;HTTP/1.0 302 Found\r\nLocation: http://www.google.se/\r\n 
Cache-Control: private\r\nSet-Cookie: PREF=ID=b57a2c:TM&quot;...&gt;&gt; 
</code></pre><p><strong>Примечание</strong>: Когда вы запускаете <code>nano_get_url</code> , то результат будет двоичный. Таким образом вы увидите, что двоичные данные выглядят, как при &quot;pretty printed&quot; в эрланговской оболочке. Когда двоичные данные печатаются в формате &quot;pretty printed&quot; все управляющие символы выводятся в escape-формате. Банарные данные выводятся не полностю, это видо по трем точкам (<code>…&gt;&gt;</code>) в конце печати. Если вы желаете увидеть все бинарные данные, можно использовать <code>io:format</code>, или разорвать банарные данные на символы, при помощи <code>string:tokens</code>: </p>
<pre><code>2&gt; io:format(&quot;~p~n&quot;,[B]).
&lt;&lt;&quot;HTTP/1.0 302 Found\r\nLocation: http://www.google.se/\r\n
    Cache-Control: private\r\nSet-Cookie: PREF=ID=b57a2c:TM&quot;
    TM=176575171639526:LM=1175441639526:S=gkfTrK6AFkybT3;
    expires=Sun, 17-Jan-2038 19:14:07
    ... several lines omitted ... 
&gt;&gt;

3&gt;string:tokens(binary_to_list(B),&quot;\r\n&quot;).
[&quot;HTTP/1.0 302 Found&quot;, 
&quot;Location: http://www.google.se/&quot;, 
&quot;Cache-Control: private&quot;, 
&quot;Set-Cookie: PREF=ID=ec7f0c7234b852dece4:TM=11713424639526: 
LM=1171234639526:S=gsdertTrK6AEybT3; 
expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com&quot;, 
&quot;Content-Type: text/html&quot;, 
&quot;Server: GWS/2.1&quot;, 
&quot;Content-Length: 218&quot;, 
&quot;Date: Fri, 16 Feb 2007 15:25:26 GMT&quot;, 
&quot;Connection: Keep-Alive&quot;, 
... lines omitted ... 
</code></pre><p><em>(3) Это верно только для HTTP/1.0; для более новых версий используются другие стратегии</em></p>
<p>Это более или менее показывает, как работает web-клиент(с уклонением в меньшую сторону — приходится делать много работы, для корректного выведения результата в веббраузерах). Предыдущий код, тем не менее, — хорошая отправная точка для ваших собственных экспериментов. Вам может понравиться модифицировать этот код, например: вы можете принимать и хранить записи веб-сайтов или автоматически прочитать ваш ваш e-mail. Возможности безграничны.</p>
<p>Заметим, что код, который собирает фрагменты выглядел так: </p>
<pre><code>receive_data(Socket, SoFar) -&gt;
    receive {tcp,Socket,Bin} -&gt;
    receive_data(Socket, [Bin|SoFar]); 
{tcp_closed,Socket} -&gt;
    list_to_binary(reverse(SoFar)) end. 
</code></pre><p>Таким образом мы добавляем прибывшие фрагменты в голову списка <code>SoFar</code>. Когда все фрагменты прибыли и сокет был закрыт мы реверсируем список и соединяем фрагменты.</p>
<p>Вы могли подумать, что сборка фрагментов таким образом было бы лучшим решением: </p>
<pre><code>receive_data(Socket, SoFar) -&gt;
    receive {tcp,Socket,Bin} -&gt;
        receive_data(Socket, list_to_binary([SoFar,Bin]));
{tcp_closed,Socket} -&gt;
    SoFar end.
</code></pre><p>Этот код корректен, но менее эффективен, чем оригинальная версия. Причина этого состоит в том, что этот код беспрестанно добавляет новые данные в конец буфера, а это включает большое копирование данных. Куда лучше добавлять фрагменты в голову списка, а потом реверсировать записи списка и собрать все фрагменты одной операцией. </p>
<h3 id="14-1-2-tcp-">14.1.2 Простой TCP сервер</h3>
<p>В предыдущем разделе мы написали простой клиент. Давайте теперь напишем сервер.</p>
<p>Сервер открывает порт 2345 и ждет одного сообщения. Это двоичное сообщение, которое содержит терм эрланга. Терм – это эрданговская строка, содержащая выражение. Сервер обрабатывает выражение и посылает результат клиенту, записывая результат в сокет. </p>
<blockquote>
<h4 id="-">Как мы можем писать веб сервер?</h4>
<p>Написание что-то вроде веб-клиента или сервера очень интересно. Действительно, многие люди уже имеют написанные эти вещи, но если вы действительно хотите понять,как это работает, копайте глубже и выяснейте. Это очень поучительно. Кто знает — может быть наш веб-сервер будет самый лучший. Так как нам начать? </p>
<p>Для создания веб-сервера, или другого программного обеспечения, которое реализует один из стандартных протокол интернета, вам необходимы правильные инструменты, а так же необходимо четко понимать, как точно этот протокол реализовать. </p>
<p>В нашем примере есть код, который получает веб-страницу. Откуда мы узнали, что надо открывать 80-ый порт. Откуда мы узнали, что серверу надо посылать именно такое сообщение: <code>GET / HTTP/1.0\r\n\r\?</code> Ответ прост. Все основные протоколы для интернет сервисов описаны в <strong>request for comments(RFCs)</strong>. <strong>HTTP/1.0</strong> описан в <strong>RFC 1945</strong>. Официальный веб-сайт для всех документов RFC — <a href="http://www.ietf.org">http://www.ietf.org</a> (сайт Internet Engineering Task Force).</p>
<p>Другой бесценный источник информации - сниффер. При помощи сниффера мы можем захватывать и анализировать все IP пакеты приходящие и уходящие от приложения. Большое количество сниферов включают программное обеспечение, которое может декодировать и анализировать данные в пакете, а так же представлять данные в выразительной форме. Один из наиболее известных и возможно лучших снифферов — это Wireshark (Ранее известный, как ethereal), доступен на <a href="http://www.wireshark.org">http://www.wireshark.org</a>.</p>
<p>Вооружившись пакетным сниффером и соответствующими документами RFC, мы готовы писать следующие убийственные приложения.</p>
</blockquote>
<p>Написав эту программу, мы сможем ответить на несколько простых вопросов:</p>
<ul>
<li>Как организованы эти данные? Как мы узнаем, сколько данных составляет один запрос или ответ?</li>
<li>Как эти данные кодируются и декодируются в пределах запроса или ответа?</li>
</ul>
<p>Данные TCP сокета — это просто недифференцируемый поток байтов. В процессе доставки эти данные могут быть фрагментированы. Поэтому нам нужно некоторое соглашение, что бы мы знали сколько байтов составляет единичный запрос или ответ. </p>
<p>В случае Эрланга мы используем простое соглашение, по которому перед каждым запросом или ответом мы приписываем перед ним 1,2 или 4 байта, которые характеризуют его длину. Это количество байт передается функциям <code>get_tcp:connect</code> и <code>gen_tcp:listen</code>, как аргумент <code>{packet,N}</code> (4). Заметим, что аргумент packet должен быть согласован между клиентом и сервером. Если сервер откроет соединение с <code>{packet,2}</code>, а клиент с <code>{packet,4}</code>, то ничего работать не будет. </p>
<p>Имея открытый сокет с опцией <code>{packet,N}</code>, мы не должны беспокоиться о фрагментации данных. Драйвер эрланга ,до передачи сообщения нашей программе, удостоверится, что все фрагменты данных собраны с правильной длиной. </p>
<p>Следующий интерес представляют кодирование и декодирование данных. Мы будем использовать простейший возмодный путь кодирования и декодирования сообщений, используя <code>term_to_binary</code> для кодирования и <code>binary_to_term</code> для декодирования. </p>
<p>Заметим, что соглашение упаковки <code>({packet,N})</code> и правила кодирования, необходимые для общения клиента и сервера, достигаются в двух строках кода: используя <code>{packet,4}</code>, когда мы открываем сокет, и <code>term_to_binary</code> — для кодирования. </p>
<p>Легкость, с которой мы можем упаковывать и кодировать эрланговские термы, дает нам значительное приемущество над text-based методами, такими как HTTP или XML. Используя эрланговский BIF <code>term_to_binary</code> и его обратный <code>binary_to_term</code>, обычно, на порядок быстрее, чем вычисление эквивалентных операций, которые использует XML термы и включают пересылку намного большего количества данных. А теперь к программам. Во-первых, вот очень простой сервер.</p>
<p>Загрузить <a href="http://media.pragprog.com/titles/jaerlang/code/socket_examples.erl">socket_examples.erl</a></p>
<pre><code>start_nano_server() -&gt; 
    {ok, Listen} = gen_tcp:listen(2345, [binary, {packet, 4},
                                         {reuseaddr, true}, 
                                         {active, true}]), 
    {ok, Socket} = gen_tcp:accept(Listen),
    gen_tcp:close(Listen),
    loop(Socket). 

loop(Socket) -&gt; 
    receive 
        {tcp, Socket, Bin} -&gt;
            io:format(&quot;Server received binary = ~p~n&quot;,[Bin]),
            Str = binary_to_term(Bin), %% (9)
            io:format(&quot;Server (unpacked) ~p~n&quot;,[Str]),
            Reply = lib_misc:string2value(Str), %% (10)
            io:format(&quot;Server replying = ~p~n&quot;,[Reply]),
            gen_tcp:send(Socket, term_to_binary(Reply)),
            loop(Socket);
        {tcp_closed, Socket} -&gt;
            io:format(&quot;Server socket closed~n&quot;)
    end. 
</code></pre><p><em>(4) Директива packet здесь означает не сколько физически байтов будет записываться в сокет, а именно длину сообщения в программе</em></p>
<h4 id="-">Как это работает?</h4>
<ol>
<li><p>Вначале мы вызываем <code>gen_tcp:listen</code>, для прослушивания 2345 порта, и устанавливаем соглашение об упаковке. {packet,4} подразумевает, что сообщению будет предшествовать 4х байтовый заголовок. Затем <code>gen_tcp:listen(…)</code> возвращает <code>{ok,Socket}</code> или <code>{error,Why}</code>, но нас интересует только тот случай, когда мы можем открыть сокет. Поэтому мы пишем следующий код: </p>
<pre><code> {ok, Listen} = gen_tcp:listen(…)
</code></pre><p>Здесь происходит сопоставление по шаблону, и если <code>get_tcp:listen</code> возвратит <code>{error, …}</code>, то будет поднято исплючение. В случае успеха, это выражение связывает Listen с прослушиваемым сокетом, и он используется в качестве аргумента в <code>geb_tcp:accept</code> </p>
</li>
<li><p>Теперь мы вызываем <code>gen_tcp:accept(Listen)</code>. В этом месте программа усыпляется и ожидает соединения. Когда соединение установлено, эта функция возвращает переменную Socket, связанную с сокетом, который может использоваться для общения с клиентом, который установил соединение. </p>
</li>
<li><p>Когда     функция accept возвращает управление, мы сразу же вызываем <code>gen_tcp:close(Listen)</code>. Функция close закрывает прослушиваемый сокет, после чего сервер становится недоступным для других соединений. Это не окахывает эффекта на имеющееся соединение; это только предотвращает новые соединения. </p>
</li>
<li><p>Мы декодируем входные данные. </p>
</li>
<li><p>Затем мы вычисляем строку. </p>
</li>
<li><p>И наконец, мы кодируем ответ и посылаем его обратно в сокет. </p>
</li>
</ol>
<p>Заметим, что эта программа принимает только один единственный запрос, потом она завершится и больше не будет принимать соединений. </p>
<p>Это простейший пример сервера, иллиюстрирующий то, как упаковываются и коидруются данные. </p>
<p>Этот код принимает запрос, вычисляет ответ, отправляет ответ, и завершается.</p>
<p>Для тестирования сервера нам потребуется соответствующий клиент: </p>
<p>Загрузить <a href="http://media.pragprog.com/titles/jaerlang/code/socket_examples.erl">socket_examples.erl</a> </p>
<pre><code>nano_client_eval(Str) -&gt; 
    {ok, Socket} = 
        gen_tcp:connect(&quot;localhost&quot;, 2345, 
                        [binary, {packet, 4}]), 
    ok = gen_tcp:send(Socket, term_to_binary(Str)), 
receive 
    {tcp,Socket,Bin} -&gt; 
        io:format(&quot;Client received binary = ~p~n&quot;,[Bin]),
        Val = binary_to_term(Bin), 
        io:format(&quot;Client result = ~p~n&quot;,[Val]), 
        gen_tcp:close(Socket) 
end. 
</code></pre><p>Для тестирования нашего кода мы запустим клиент и сервер на одной машине, поэтому адрес хоста жестко прописан в функции <code>gen_tcp:connect</code>, как <code>localhost</code>. Заметим, что <code>term_to_binary</code> вызывается клиентом для кодирования сообщения и <code>binary_to_term</code> вызывается сервером, для переконструирования пришедшего сообщения. Для запуска этого кода нам потребуется открыть два терминала и запустить эрланговскую оболочку в каждом их них. В начале мы запустим сервер: </p>
<pre><code>1&gt; socket_examples:start_nano_server().
</code></pre><p>Мы не увидим другого вывода, пока ничего не происходит. Затем перейдем к клиенту и напишем следующую команду:</p>
<pre><code>1&gt; socket_examples:nano_client_eval(&quot;list_to_tuple([2+3*4,10+20])&quot;
</code></pre><p>В окне с сервером мы должны увидеть следующее: </p>
<pre><code>Server received binary = &lt;&lt;131,107,0,28,108,105,115,116,95,116,
                            111,95,116,117,112,108,101,40,91,50,
                            43,51,42,52,44,49,48,43,50,48,93,41&gt;&gt; 
Server (unpacked) &quot;list_to_tuple([2+3*4,10+20])&quot;
Server replying = {14,30} 
</code></pre><p>В окне с клиентом мы должны увидеть такой текст: </p>
<pre><code>Client received binary = &lt;&lt;131,104,2,97,14,97,30&gt;&gt; 
Client result = {14,30} 
ok 
</code></pre><p>И в конце концов в серверном окне будет вот так: </p>
<pre><code>Server socket closed 
</code></pre><h3 id="14-1-3-">14.1.3 Улучшение сервера</h3>
<p>В предыдущем разделе мы сделали сервер, который принимает только одно соединение,после чего завершается. Чуть-чуть изменив код мы можем получить два различных вида серверов: </p>
<ol>
<li><p>Последовательный — принимает одное соединение единовременно. </p>
</li>
<li><p>Параллельный сервер — множество параллельных соединений единовременно. </p>
</li>
</ol>
<p>Изначальная версия кода выглядит так: </p>
<pre><code>start_nano_server() -&gt;
    {ok, Listen} = gen_tcp:listen(...),
    {ok, Socket} = gen_tcp:accept(Listen), 
    loop(Socket). ... 
</code></pre><p>Будем изменять этот код, и получим два варианта серверов. </p>
<h3 id="14-1-4-">14.1.4 Последовательный сервер</h3>
<p>Для создания последовательного сервера мы изменим код следующим образом: </p>
<pre><code>start_seq_server() -&gt; 
    {ok, Listen} = gen_tcp:listen(...), 
    seq_loop(Listen). 

seq_loop(Listen) -&gt; 
    {ok, Socket} = gen_tcp:accept(Listen), 
    loop(Socket), 
    seq_loop(Listen). 

loop(..) -&gt; %% по-старому 
</code></pre><p>Этот код работает почти как и предыдущий, но так как мы хотим обрабатывать больше одного запроса, мы оставляем прослушиваемый сокет открытым и не вызываем <code>gen_tcp:close(Listen)</code>. </p>
<p>Другое отличие, что после того, как <code>loop(Socket)</code> завершится, мы вызываем <code>seq_loop(Listen)</code> снова, где и ожидается следующее соединение. </p>
<p>Если клиент попытается соединиться с сервером, пока он занят с имеющимся соединением, то тогда он будет поставлен в очередь, пока сервер не закончит обработку текущего соединения. Если число соединений в очереди будет превышать значение listen backlog, тогда соединения будут отвергаться. </p>
<p>Мы показали код, который только запускает сервер. Останов сервера прост(как и останов параллельного); просто убейте процесс, который запускал сервер или серверы. gen_tcp связывает себя с контроллируемыми процессами. И если контроллируемый процесс умирает, то это закрывает сокет. </p>
<h3 id="14-1-5-">14.1.5 Параллельный сервер</h3>
<p>Трюк создания параллельного сервера немедленно порождает дочерний процесс, когда 
<code>gen_tcp:accept</code> получает новое соединение: </p>
<pre><code>start_parallel_server() -&gt; 
    {ok, Listen} = gen_tcp:listen(...), 
    spawn(fun() -&gt;     par_connect(Listen) end).

par_connect(Listen) -&gt; 
    {ok, Socket} = gen_tcp:accept(Listen), 
    spawn(fun() -&gt; par_connect(Listen) end), 
    loop(Socket).

loop(..) -&gt; %% как и раньше 
</code></pre><p>Этот код схож с последовательным сервером, который вы видели ранее. Решающее различие заключается в добавлении функции spawn, которая гарантирует создание параллельных процессов, для каждого нового соединения. Вы должны взглянуть на место, где стоит spawn и увидеть, как эта функция превращает последовательный сервер в параллельный. </p>
<p>Все эти сервера вызывают <code>gen_tcp:listen</code> и <code>gen_tcp:accept</code>; единственное различие заключается в том, что мы называем эти функции параллельной программой или последовательной программой. </p>
<h3 id="14-1-6-">14.1.6 Заметки</h3>
<p>Будем осведомлены о следующем: </p>
<ul>
<li>Процесс, который создает сокет (вызывая <code>gen_tcp:accept</code> или <code>gen_tcp:connect</code>) называется процессом, контроллирующем этот сокет. Все сообщения из сокета будут отправляться контроллирующему процессу; Если контроллирующий процесс умирает, тогда сокет будет закрыт. Контроллирующий процесс может быть изменен на NewPid при помощи вызова <code>gen_tcp:controlling_process(Socket,NewPid)</code>. </li>
<li>Наш сервер потенциально может установить многие тысячи соединений. Возможно, мы захотим ограничить максимальное число одновременных соединений. Это может быть реализовано при помощи счетчика того, сколько соедиений сейчас установлено. Мы инкрементируем его, если поступает новое соединение, и декрементируем, если соединение завершается. Мы можем использовать этот механизм для ограничения общего числа одновременных соединений в системе. </li>
<li><p>После принятия соединения хорошей идеей будет явное задание необходимых опций сокета,вот так: </p>
<pre><code>  {ok, Socket} = gen_tcp:accept(Listen), 
  inet:setopts(Socket, [{packet,4},binary, 
                          {nodelay,true},{active, true}]), 
  loop(Socket)
</code></pre></li>
<li>В версии эрланга R11B-3 раличным процессам позволено вызывать <code>gen_tcp:accept</code> для одного и того же сокета. Это простейший пример параллельного сервера, поскольку мы можем иметь кучу заранее порожденных процессов, каждый из которых будет ожидать соединения при помощи <code>gen_tcp:accept/1</code>. </li>
</ul>
<h2 id="14-2-">14.2 Контроллирование проблемы</h2>
<p>Эрланг-сокет может быть открыт в одном из трех режимов: <em>активный, единыжды активный, пассивный</em>. Это достигается включением опции <code>{active,true|false|once}</code> в аргумент Options одной из двух функций <code>gen_tcp:connect(Adress,Port,Options)</code> или <code>gen_tcp:listen(Port,Options)</code>. </p>
<p>Если указано <code>{active,true}</code>, тогда будет создан активный сокет; <code>{active,false}</code> указывает на создание пассивного сокета. <code>{active,once}</code> создает сокет, который будет активным, но только до приема одного сообщения; после того, как сообщение будет принято, сокет сделается пассивным до того момента, как сможет принять новое сообщение. </p>
<p>В следующих разделах мы посмотрим, как применяются эти различные виды сокетов. Различие между активным и пассивным режимом заключается в том, как происходит прием сообщения сокетом. </p>
<ul>
<li>Если был создан активный сокет, тогда контроллирующему процессу будут приходить кортежи вида <code>{tcp,Socket,Data}</code> в почтовый ящик. В этом случае контроллирующий процесс никак не сможет контроллировать поток сообщений. Злоумышленник может отправить тысячи сообщений системе, и все они будут доставлены контроллирующему процессу. Контроллирующий процесс никак не сможет сотановить этот поток сообщений. </li>
<li>Если сокет был открыт в пассивном режиме, тогда для приема сообщений с сокета контроллирующий процесс вызывает <code>gen_tcp:recv(Socket,N)</code>. Этот вызов будет пытаться получить ровно <code>N</code> байт из сокета. Если <code>N = 0</code>, тогда все доступные байты будут возвращены.В этом случае сервер может контроллировать поток байтов от клиента, выбирая, когда использовать <code>gen_tcp:recv</code>. </li>
</ul>
<p>Пассивный режим используется для контроллирования потока, который идет на сервер. Для иллюстрации этого мы можем написать функцию по приему сообщений в трех видах: </p>
<ul>
<li>Активный прием сообщений(неблокирующий) </li>
<li>Пассивый прием сообщений(блокирующий) </li>
<li>Гибридный прием сообщений(частичное блокирование) </li>
</ul>
<h3 id="14-2-1-">14.2.1 Активный прием сообщений(неблокирующий)</h3>
<p>В нашем первом примере мы открываем сокет в активном режиме и затем принимаем сообщения с сокета: </p>
<pre><code>{ok, Listen} = gen_tcp:listen(Port, [..,{active, true}...]), 
{ok, Socket} = gen_tcp:accept(Listen), 
loop(Socket). 

loop(Socket) -&gt; 
    receive
        {tcp, Socket, Data} -&gt; 
            ... делаем что-то с Data ... 
        {tcp_closed, Socket} -&gt; 
            ... 
    end. 
</code></pre><p>Этот процесс не может контроллировать поток сообщений к серверу. Если клиент производит данные быстрее, чем сервер может обработать, тогда система может быть зафлужена(ﬂooded) сообщениями — буфер сообщений заполнится и система может упасть или вести себя странно. </p>
<p>Этот тип сервера называется неблокирующим сервером, потому что он не может блокировать клиента. Мы должны писать неблокирующие сервера, только в том случае, когда мы можем быть уверены, что сервер сможет справиться с запросами клиентов. </p>
<h3 id="14-2-2-">14.2.2 Пассивный прием сообщений(блокирующий)</h3>
<p>В этом разделе мы напишем блокирующий сервер. Сервер открывает сокет в пассивном режиме, устанавливая опцию <code>{active,false}</code>. Сервер не может обрушиться из-за гиперактивного клиента, который пытается зафлудить его большим количеством данных. </p>
<p>Код в функции <code>loop</code> вызывает <code>gen_tcp:recv</code> все время, когда нужно принять данные. Клиент будет заблокирован, пока сервер вызывает <code>recv</code>. Заметим,что ОС тоже буферизует данные, что позволяет клиенту отправить большое количество данных пока он заблокирован, даже если <code>recv</code> не вызывалась. </p>
<pre><code>{ok, Listen} = gen_tcp:listen(Port, [..,{active, false}...]), 
{ok, Socket} = gen_tcp:accept(Listen), 
loop(Socket). 

loop(Socket) -&gt; 
    case gen_tcp:recv(Socket, N) of 
        {ok, B} -&gt; 
            ... делаем что-то с данными ... 
            loop(Socket);
        {error, closed} 
            ... end. 
</code></pre><h3 id="14-2-3-">14.2.3 Гибридный подход(частичное блокирование)</h3>
<p>Вы можете подумать,что использование пассивного режима для всех серверов — это корректный подход. К сожалению, это не так, когда мы были в пассивном режиме, мы могли ожидать данные только с одного сокета. Это не годится для написания серверов, которые должны ожидать данные со многих сокетов. </p>
<p>К счастью, мы можем применить гибридный подход, когда никто ни неблокирующий, ни блокирующий. Мы открываем сокет с опцией <code>{active,once}</code>. В этом режиме сокет активен, но только до первого сообщения. После того,как контроллирующему процессу было послано сообщение, необходимо вызвать <code>inet:setops</code>, что бы включить прием следующего сообщения. Система будет блокировать прием, пока это не произойдет. Это лучше, чем два других метода. Вот как выглядит этот код: </p>
<pre><code>{ok, Listen} = gen_tcp:listen(Port, [..,{active, once}...]), 
{ok, Socket} = gen_tcp:accept(Listen), 
loop(Socket). 

loop(Socket) -&gt;
    receive 
        {tcp, Socket, Data} -&gt;
            ... do something with the data ... 
            %% когда вы готовы принять следующее сообщение
            inet:setopts(Sock, [{active, once}]), loop(Socket); 
        {tcp_closed, Socket} -&gt; 
            ...
    end. 
</code></pre><p>Использвуя <code>{active,once}</code> опцию пользователь может осуществлять продвинутые формы контроля потока (иногда это называется traﬃc-shaping) и ,таким образом, предотвращать зафлужевание(ﬂooded) сервера чрезмерными сообщениями. </p>
<h2 id="14-3-">14.3 Откуда это соединение к нам пришло?</h2>
<p>Допустим, мы написали некоторый вид онлайн сервера и заметили,что кто-то спамит наш сайт. Как мы можем на это отреагировать? Первым делом необходимо узнать, откуда поступило это соединение. Чтобы это определить мы можем использовать inet:peername(Socket). </p>
<p><code>@spec inet:peername(Socket) -&gt; {ok, {IP_Address, Port}} | {error, Why}</code></p>
<p>Эта функция возвращает IP адрес и порт другого конца соединения, таким образом сервер может определить кто инициировал соединение. IP_Adress это кортеж из целых чисел,для IPv4 имеет вид <code>{N1,N2,N3,N4}</code>, а для IPv6 <code>{K1,K2,K3,K4,K5,K6}</code>. Ni и Ki числа в дипазоне от 0 до 255. </p>
<h2 id="14-4-">14.4 Обработка ошибок сокетов</h2>
<p>Обработка ошибок сокета это очень просто, по существу вам ничего не надо делать. Как говорилось ранее, каждый сокет имеет контроллирующий процесс(тоесть процесс, который создал сокет). Если контроллирующий процесс умирает, тогда сокет автоматически хакрывается. </p>
<p>Это значит,что если, например, вы имеете клиент и сервер, и сервер падает из-за программной ошибки, то сокет, который принадлежил серверу будет автоматически закрыт, и клиенту будет послан кортеж <code>{tcp_closed,Socket}</code>. </p>
<p>Мы можем протестировать этот механизм со следующий программой: </p>
<p>Загрузить <a href="http://media.pragprog.com/titles/jaerlang/code/socket_examples.erl">socket_examples.erl</a></p>
<pre><code>error_test() -&gt; 
    spawn(fun() -&gt; error_test_server() end), 
    lib_misc:sleep(2000), 
    {ok,Socket} = gen_tcp:connect(&quot;localhost&quot;,4321,[binary, {packet, 2}]),
    io:format(&quot;connected to:~p~n&quot;,[Socket]), 
    gen_tcp:send(Socket, &lt;&lt;&quot;123&quot;&gt;&gt;), 
    receive 
        Any -&gt; 
            io:format(&quot;Any=~p~n&quot;,[Any]) end. 

error_test_server() -&gt; 
    {ok, Listen} = gen_tcp:listen(4321, [binary,{packet,2}]), 
    {ok, Socket} = gen_tcp:accept(Listen), 
    error_test_server_loop(Socket). 

error_test_server_loop(Socket) -&gt; 
    receive 
        {tcp, Socket, Data} -&gt; 
            io:format(&quot;received:~p~n&quot;,[Data]), 
            atom_to_list(Data), 
            error_test_server_loop(Socket) 
    end. 
</code></pre><p>Когда мы запустим ее, мы увидим следующее: </p>
<pre><code>1&gt; socket_examples:error_test(). 
connected to:#Port&lt;0.152&gt; 
received:&lt;&lt;&quot;123&quot;&gt;&gt; 
=ERROR REPORT==== 9-Feb-2007::15:18:15 === 
Error in process &lt;0.77.0&gt; with exit value: 
    {badarg,[{erlang,atom_to_list,[&lt;&lt;3 bytes&gt;&gt;]}, 
    {socket_examples,error_test_server_loop,1}]} 
Any={tcp_closed,#Port&lt;0.152&gt;} 
ok 
</code></pre><p>при помощи spawn мы породили сервер, затем усыпились на 2 секунды (чтобы сервер успел запуститься), и затем отправляем сообщение, содержащее <code>&lt;&lt;&quot;123&quot;&gt;&gt;</code>. Когда это сообщение приходит, сервер пытается вычислить <code>atom_to_list(Data)</code>, где <code>Data</code> — это бинарные данные, и немедленно падает(5). Теперь, когда контроллирующий процесс(со стороны сервера) обрущился, сокет автоматически закрывается. Затем клиенту отправляется сообщение <code>{tcp_closed,Socket}</code>. </p>
<p><em>(5)системный монитор печатает диагностическое сообщение, которое вы видите в оболочке</em></p>
<h2 id="14-5-udp">14.5 UDP</h2>
<p>Теперь давайте рассмотрим User Datagram Protocol (UDP). Используя UDP, машины могут отправлять друг другу коротенькие сообщения по интернет, которые называются дейтаграммы. UDP дейтаграммы ненадежны. Это значит что если клиент отправил последователность UDP дейтаграм серверу, то они могут прийти не в том порядке,в каком отправлялись, могут прийти не все, или дейтаграммы могут продублироваться, но если одна дейтаграмма пришла на сервер, то она будет неповрежденной. Большие дейтаграммы могут быть разбиты на маленькие фрагменты, но IP протокол будет собирать фрагменты, перед передачей приложению. </p>
<p>UDP устроен так, что до отправки дейтаграммы между клиентом и сервером не установлено соединение. Это значит,что UDP хорошо преспособлен для приложений, у которых большое число клиентов, которые отправляют короткие сообщения серверу. </p>
<p>Создание UDP клиента и сервера в Эрланге еще проще, чем создание клиента или сервера на TCP, если мы не беспокоимся о поддержке соединения. </p>
<h3 id="14-5-1-udp-">14.5.1 Простейший UDP сервер и клиент</h3>
<p>Давайте вначале обсудим сервер. Основной вид UDP сервера следующий: </p>
<pre><code>server(Port) -&gt; 
{ok, Socket} = gen_udp:open(Port, [binary]),
loop(Socket). 

loop(Socket) -&gt; 
    receive 
        {udp, Socket, Host, Port, Bin} -&gt; 
            BinReply = ... , 
            gen_udp:send(Socket, Host, Port, BinReply), 
            loop(Socket)
    end. 
</code></pre><p>Этот код, отчасти, проще кода с TCP, поскольку мы не беспокоимся о приеме сообщения &quot;socket closed&quot;. Заметим, что открыли сокет в бинарном режиме, что говорит драйверу отправлять все сообщения контроллирующему процессу, как бинарные данные. </p>
<p>Теперь клиент. Тут просто открывается UDP сокет, отправляется сообщение серверу, ожидается ответ(или таймаут), и затем закрывается сокет и возвращается значение, которое пришло от сервера. </p>
<pre><code>client(Request) -&gt; 
    {ok, Socket} = gen_udp:open(0, [binary]), 
    ok = gen_udp:send(Socket, &quot;localhost&quot; , 4000, Request), 
    Value = receive 
                {udp, Socket, _, _, Bin} -&gt; 
                    {ok, Bin} 
            after 2000 -&gt; 
                error 
            end, 
    gen_udp:close(Socket), 
    Value 
</code></pre><p>Мы должны выставить таймаут, поскольку UDP ненадежный, мы можем просто не получить ответа. </p>
<h3 id="14-5-2-udp-">14.5.2 UDP факториал сервер</h3>
<p>Мы легко можем создать модуль UDP сервера, который подсчитывает факториал любого целого числа, которого ему отправили. Код сделан по аналогии с предыдущим разделом. </p>
<p>Загрузить <a href="http://media.pragprog.com/titles/jaerlang/code/udp_test.erl">udp_test.erl</a></p>
<pre><code>-module(udp_test).
-export([start_server/0, client/1]).

start_server() -&gt;
    spawn(fun() -&gt; server(4000) end).

%% Сервер 
server(Port) -&gt; 
    {ok, Socket} = gen_udp:open(Port, [binary]), 
    io:format(&quot;server opened socket:~p~n&quot;,[Socket]), 
    loop(Socket). 

loop(Socket) -&gt; 
    receive 
        {udp, Socket, Host, Port, Bin} = Msg -&gt; 
            io:format(&quot;server received:~p~n&quot;,[Msg]), 
            N = binary_to_term(Bin), 
            Fac = fac(N), 
            gen_udp:send(Socket, Host, Port, term_to_binary(Fac)), 
            loop(Socket) 
    end. 

    fac(0) -&gt; 1; 
    fac(N) -&gt; N * fac(N-1). 

    %% Клиент 
    client(N) -&gt; 
        {ok, Socket} = gen_udp:open(0, [binary]), 
        io:format(&quot;client opened socket=~p~n&quot;,[Socket]), 
        ok = gen_udp:send(Socket, &quot;localhost&quot;, 4000, 
                            term_to_binary(N)), 
        Value = receive 
                    {udp, Socket, _, _, Bin} = Msg -&gt; 
                        io:format(&quot;client received:~p~n&quot;,[Msg]), 
                        binary_to_term(Bin) 
                after 2000 -&gt; 
                    0
                end, 
        gen_udp:close(Socket), 
        Value. 
</code></pre><p>Обратите внимание,что я добавил несколько отладочных печатей, что бы вы увидели что происходит, когда запускается программа.Я всегда добавляю несколько отладочных печатей, когда разрабатываю программу, и затем комментирую или редактирую их во время работы программы. </p>
<p>Теперь давайте запустим этот пример. Вначале запустим сервер. </p>
<pre><code>1&gt; udp_test:start_server().
server opened socket:#Port&lt;0.106&gt; 
&lt;0.34.0&gt; 
</code></pre><p>Он запускается в фоновом режиме, теперь мы можем сделать клиентский запрос: </p>
<pre><code>2&gt; udp_test:client(40). 
client opened socket=#Port&lt;0.105&gt; 
server received:{udp,#Port&lt;0.106&gt;,{127,0,0,1},32785,&lt;&lt;131,97,40&gt;&gt;} 
client received:{udp,#Port&lt;0.105&gt;, 
                    {127,0,0,1}, 4000, 
                    &lt;&lt;131,110,20,0,0,0,0,0,64,37,5,255, 
                    100,222,15,8,126,242,199,132,27, 
                    232,234,142&gt;&gt;} 
815915283247897734345611269596115894272000000000 
</code></pre><h3 id="14-5-3-udp">14.5.3 Дополнительные замечания про UDP</h3>
<p>Мы должны отметить, что UDP не устанавливает соединения между клиентом и сервером, сервер не имеет методов блокировать клиента, отвергая чтение данных —сервер не имеет представления, кто является клиентом. </p>
<p>Большие UDP пакеты могут фрагментироваться, по мере прохождения через сеть. Фрагментация имеет место, когда размер UDP данных превышает величину maximum transfer unit (MTU), эта величина определяется узлами сети, через которые проходит пакет. Обычно, при настройке сети, рекомндуют на начальном этапе выставить MTU около 500 байтов, и затем постепенно увеличивать с измерение пропускной способности сети. Если на некотором узле пропускная способность резко упадет, тогда вы узнаете, что пакет является очень большим. </p>
<p>UDP пакеты могут быть доставлены дважды(что удивит некоторых людей), таким образом вы должны быть осторожны, когда пишете код для удаленных процедурных вызовов. Это может произойти, если ответ сервера на второй запрос совпадает с ответом сервера на первый запрос. Что бы избежать этого мы должны модифицировать клиентский код, включением уникальных идентификаторов, и проверкой, что сервер возвращает этот идентификатор. Для генерации уникальных идентификаторов, мы вызываем BIF make_ref, которая гарантирует возвращение глобального уникального идентификатора. Код для удаленного процедурного вызова теперь выглядит так: </p>
<pre><code>client(Request) -&gt; 
    {ok, Socket} = gen_udp:open(0, [binary]), 
    Ref = make_ref(), %% создание уникального идентификатора 
    B1 = term_to_binary({Ref, Request}), 
    ok = gen_udp:send(Socket, &quot;localhost&quot; , 4000, B1), 
    wait_for_ref(Socket, Ref). 

wait_for_ref(Socket, Ref) -&gt; 
    receive 
        {udp, Socket, _, _, Bin} -&gt; 
            case binary_to_term(Bin) of 
                {Ref, Val} -&gt; 
                    %% получено корректное число 
                    Val; 
                {_SomeOtherRef, _} -&gt; 
                    %% пришло какое-то другое число. отбрасываем его. 
                    wait_for_ref(Socket, Ref) 
            end; 
    after 1000 -&gt; 
        ... 
    end. 
</code></pre><h2 id="14-6-">14.6 Широковещание на множество машин</h2>
<p>Для полноты картины, я покажу вам, как создавать широковещательный канал. Этот код вряд ли вам пригодится, но возможно, что в один день вам он понадобится. </p>
<p>Загрузить <a href="http://media.pragprog.com/titles/jaerlang/code/broadcast.erl">broadcast.erl</a></p>
<pre><code>-module(broadcast).
-compile(export_all).

send(IoList) -&gt; 
    case inet:ifget(&quot;eth0&quot;, [broadaddr]) of 
        {ok, [{broadaddr, Ip}]} -&gt; 
            {ok, S} = gen_udp:open(5010, [{broadcast, true}]), 
            gen_udp:send(S, Ip, 6000, IoList), 
            gen_udp:close(S); 
        _ -&gt; 
            io:format(&quot;Bad interface name, or\n&quot; 
                        &quot;broadcasting not supported\n&quot;) 
    end. 

listen() -&gt; 
    {ok, _} = gen_udp:open(6000), 
    loop(). 

loop() -&gt; 
    receive 
        Any -&gt; 
            io:format(&quot;received:~p~n&quot;, [Any]), 
            loop() 
    end. 
</code></pre><p>Здесь нам понадобится два порта, один будет широковещать, а остальные прослушивать. Мы выбрали 5010 порт для отправки широковещательных запросов и 6000 для прослушивания широковещательного траффика(Эти два числа не имеют значения; я просто выбрал два свободных порта на моей системе). </p>
<p>Открытие 5010 порта производит только тот процесс, который производит широковещательную рассылку, а все остальные машины в сети вызывают <code>broadcast:listen()</code>, для открытия 6000 порта и прослушивания широковещательных сообщений. <code>broadcast:send(IoList)</code> посылает всем машинам в локальной сети IoList широковещательным сообщением. </p>
<p><em>Примечание:</em> что бы это заработало, имя сетевого интерфейса должно быть корректным, и в локальной сети должно поддерживаться широковещание. На моем iMac, например, я использую имя &quot;en0&quot;вместо &quot;eth0&quot;. Заметим так же, что если хост, который производит широковещание и хост, который прослушивает UDP широковещательный траффик находятся в разных подсетях, то второй вряд ли услышит первого, поскольку по умолчанию маршрутизаторы не пропускают широковещательные сообщения за пределы подсети. </p>
<h2 id="14-7-shoutcast-">14.7 SHOUTcast сервер</h2>
<p>В завершении этого раздела, мы используем новоприобретенные навыки в сокет–программировании для написания SHOUTcast сервера. SHOUTcast — это протокол, который разработали в Nullsoft, для потокового вещания аудио данных(6). SHOUTcast отправляет MP3 или AAC закодированные аудиоданные, используя HTTP, как транспортный протокол. Что бы увидеть, как это работает, вначале мы посмотрим SHOUTcast протокол. Затем мы посмотрим на общие структуры серверов, и закончим написанием кода. </p>
<h3 id="14-7-1-shoutcast-">14.7.1 SHOUTcast протокол</h3>
<p>протокол SHOUTcast довольно прост: </p>
<ol>
<li><p>Вначале клиент(который может быть чем-то вроде XMMS, Winamp или iTunes) посылает HTTP запрос SHOUTcast серверу. Вот запрос, который XMMS генерирует, когда я запускаю мой SHOUTcast сервер дома: </p>
<pre><code> GET / HTTP/1.1 
 Host: localhost 
 User-Agent: xmms/1.2.10 
 Icy-MetaData:1 
</code></pre></li>
<li><p>Мой SHOUTcast сервер отвечает вот так: </p>
<pre><code> ICY 200 OK 
 icy-notice1: &lt;BR&gt;This stream requires 
 &lt;a href=http://www.winamp.com/&gt;;Winamp&lt;/a&gt;&lt;BR&gt; 
 icy-notice2: Erlang Shoutcast server&lt;BR&gt; 
 icy-name: Erlang mix 
 icy-genre: Pop Top 40 Dance Rock 
 icy-url: http://localhost:3000 
 content-type: audio/mpeg 
 icy-pub: 1 
 icy-metaint: 24576 
 icy-br: 96 
 ... data ... 
</code></pre></li>
<li><p>Теперь SHOUTcast сервер посылает непрерывный поток данных. данные имеют следующую структуру: </p>
<pre><code> H0 F H F H F H ...(7)
</code></pre></li>
</ol>
<p><code>F</code> — это блок MP3 аудио данных, который должен быть ровно 24 576 байов(число получено из icy-metaint параметра). </p>
<p><code>H</code> — это блок метаданных. Первый байт блока <code>H</code> есть целое число <code>К</code>, <code>16*K</code> — это длина блока метаданных(без учета первого байта). Блок метаданных содержит строку вида: <code>StreamTitle=’ ...’; SreamUrl=’ ...’;</code>. Если длина этой строки не кратна <code>16</code>, то оставшиеся байты будут забиты нулями. </p>
<p>Заметим так же, что наикратчайший блок метаданных выглядит так <code>&lt;&lt;0&gt;&gt;</code>. То есть один байт длины с нулями. </p>
<p><em>(6) <a href="http://www.shoutcast.com/">http://www.shoutcast.com/</a></em></p>
<p><em>(7) От автора перевода: В оригинальном тексте не упоминается про блок H0(хотя в коде он есть), но для лучшего восприятия я решил его написать. этот блок генерируется единожды, когда клиент отправляет запрос на получение данных. H0 генерируется функцией <code>responce()</code>.</em></p>
<h3 id="14-7-2-shoutcast-">14.7.2 Как SHOUTcast сервер работает</h3>
<p>Для создания сервера, мы будем соблюдать следующие детали: </p>
<ol>
<li><p>Сделаем плейлист. Наш сервер будет использовать файл с ID3 тэгами, который мы создали в Главе 13.2. Песни будут выбираться случайным образом. </p>
</li>
<li><p>Сделаем параллельный сервер, таким образом мы сможем обслуживать несколько потоков параллельно. Мы сделаем это, используя технику, которая описана в 14.1(Параллельный сервер, на странице 254). </p>
</li>
<li><p>Из каждого файла мы будем отправлять только аудиоданные, без ID3 тэгов(8). Для удаления ID3 тэгов, мы будем использовать код из id3_tag_length; этот код использует код, разработанный на странице 232, код из раздела 5.3, Поиск и синхронизация фреймов в MPEG данных, на странице 92. Этот код не будет показан здесь. </p>
</li>
</ol>
<p><em>(8) Непонятно, является ли это правильной стратегией. Аудио кодировщики предполагают перескакивание очень плохих данных, поэтому, мы можем отправлять ID3 тэги вместе с аудио-данными. Но на деле, кажется, что программа работает лучше, если мы удалим ID3 тэги.</em></p>
<h3 id="14-7-3-shoutcast-">14.7.3 Псведокод для SHOUTcast сервера</h3>
<p>Перед тем,как мы увидим финальную программу, давайте взглянем на общий вид программы, опустив некоторые детали: </p>
<pre><code>start_parallel_server(Port) -&gt; 
    {ok, Listen} = gen_tcp:listen(Port, ..), 
    %% создание музыкального сервера -- он просто знает обо всей нашей музыке.         PidSongServer = spawn(fun() -&gt;     songs() end), 
    spawn(fun() -&gt; par_connect(Listen, PidSongServer) end). 

    %% порождение одного из процессов на ожидание соединения 
    par_connect(Listen, PidSongServer) -&gt; 
        {ok, Socket} = gen_tcp:accept(Listen), 
        %% когда accept возвращает управление, мы порождаем 
        %% новый процесс для ожидания соединения. 
        spawn(fun() -&gt; par_connect(Listen, PidSongServer) end), 
        inet:setopts(Socket, [{packet,0},binary, {nodelay,true},
                                {active, true}]), 
        %% deal with the request 
        get_request(Socket, PidSongServer, []). 

%% ожидает TCP соединение 
get_request(Socket, PidSongServer, L) -&gt; 
    receive 
        {tcp, Socket, Bin} -&gt; 
            ... Bin содержит клиентский запрос 
            ... если запрос фрагментирован, то мы вызываем loop снова ... 
            ... иначе мы вызываем 
            ... got_request(Data, Socket, PidSongServer) 
        {tcp_closed, Socket} -&gt; 
            ... это происходит, если клиент обрывает соединение 
            ... до того, как успел послать запрос (маловероятно) 
        end. 

%% мы получили запрос --отправим ответ 
got_request(Data, Socket, PidSongServer) -&gt; 
    .. data -это клиентский запрос ... 
    .. анализируем его ... 
    .. мы будем всегда обслуживать запрос ..
    gen_tcp:send(Socket, [response()]), 
    play_songs(Socket, PidSongServer). 

%% будем проигрывать песни, пока клиент не отсоединится. 
play_songs(Socket, PidSongServer) -&gt; 
    ... PidSongServer хранит список всех MP3 данных 
    Song = rpc(PidSongServer, random_song), 
    ... Song -это случайная песня ... 
    Header = make_header(Song), 
    ... создание блока метаданных ... 
    {ok, S} = file:open(File, [read,binary,raw]), 
    send_file(1, S, Header, 1, Socket), 
    file:close(S), 
    play_songs(Socket, PidSongServer). 

send_file(K, S, Header, OffSet, Socket) -&gt; 
    ... отправка файла клиенту фрагментами ... 
    ... эта функция возвращает управление, когда файл отправлен ... 
    ... если произошла ошибка, при записи в сокет 
    ... это означает, что клиент отсоединился. 
</code></pre><p>Если вы посмотрите на реальный код, то вы увидите, что детали слегка отличаются, но идея так же самая. Вот полный листинг: </p>
<p>Загрузить <a href="http://media.pragprog.com/titles/jaerlang/code/shout.erl">shout.erl</a></p>
<pre><code>-module(shout). 

%% в одном окне &gt; shout:start() 
%% в дургих окнах xmms http://localhost:3000/stream 

-export([start/0]). 
-import(lists, [map/2, reverse/1]). 

-define(CHUNKSIZE, 24576). 

start() -&gt; 
    spawn(fun() -&gt; 
                    start_parallel_server(3000), 
                    %% теперь усыпляемся, посколько если это не сделать, 
                    %% то прослушиваемый сокет будет закрыт. 
                    lib_misc:sleep(infinity) 
          end). 

start_parallel_server(Port) -&gt; 
    {ok, Listen} = gen_tcp:listen(Port, [binary, {packet, 0}, 
                                            {reuseaddr, true}, 
                                            {active, true}]), 
    PidSongServer = spawn(fun() -&gt; songs() end), 
    spawn(fun() -&gt; par_connect(Listen, PidSongServer) end). 

par_connect(Listen, PidSongServer) -&gt; 
    {ok, Socket} = gen_tcp:accept(Listen), 
    spawn(fun() -&gt; par_connect(Listen, PidSongServer) end), 
    inet:setopts(Socket, [{packet,0},binary, {nodelay,true},{active, true}]), 
    get_request(Socket, PidSongServer, []). 

get_request(Socket, PidSongServer, L) -&gt; 
    receive 
        {tcp, Socket, Bin} -&gt; 
            L1 = L ++ binary_to_list(Bin), 
            %% split checks if the header is complete 
            case split(L1, []) of 
                more -&gt; 
                    %% заголовок собран не полностью, нужно больше данных.
                    get_request(Socket, PidSongServer, L1); 
                {Request, _Rest} -&gt; 
                    %% заголовок собран полностью 
                    got_request_from_client(Request, Socket, PidSongServer) 
            end; 
        {tcp_closed, Socket} -&gt; 
            void; 
        _Any -&gt; 
            %% пропустим это 
            get_request(Socket, PidSongServer, L) 
    end. 

split(&quot;\r\n\r\n&quot; ++ T, L)     -&gt; {reverse(L), T}; 
split([H|T], L)             -&gt; split(T, [H|L]); 
split([], _)                 -&gt; more. 

got_request_from_client(Request, Socket, PidSongServer) -&gt; 
    Cmds = string:tokens(Request, &quot;\r\n&quot; ), 
    Cmds1 = map(fun(I) -&gt; string:tokens(I, &quot; &quot; ) end, Cmds), 
    is_request_for_stream(Cmds1),
    gen_tcp:send(Socket, [response()]),
    play_songs(Socket, PidSongServer, &lt;&lt;&gt;&gt;). 

play_songs(Socket, PidSongServer, SoFar) -&gt; 
    Song = rpc(PidSongServer, random_song), 
    {File,PrintStr,Header} = unpack_song_descriptor(Song), 
    case id3_tag_lengths:file(File) of 
        error -&gt; 
            play_songs(Socket, PidSongServer, SoFar); 
        {Start, Stop} -&gt; 
            io:format(&quot;Playing:~p~n&quot; ,[PrintStr]), 
            {ok, S} = file:open(File, [read,binary,raw]), 
            SoFar1 = send_file(S, {0,Header}, Start, Stop, Socket, SoFar), 
            file:close(S), 
            play_songs(Socket, PidSongServer, SoFar1) 
    end. 

send_file(S, Header, OffSet, Stop, Socket, SoFar) -&gt; 
    %% OffSet = первый байт аудиоданных. 
    %% Stop = последний байт аудиоданных. 
    Need = ?CHUNKSIZE -size(SoFar), 
    Last = OffSet + Need, 
    if 
        Last &gt;= Stop -&gt; 
            %% даже если мы и дочитаем файл до конца, то мы не 
            %% наберем байтов до 24576, поэтому вычитываем, что есть 
            %% и возвращаемся в play_songs 
            Max = Stop - OffSet, 
            {ok, Bin} = file:pread(S, OffSet, Max), 
            list_to_binary([SoFar, Bin]); 
        true -&gt; 
            {ok, Bin} = file:pread(S, OffSet, Need), 
            write_data(Socket, SoFar, Bin, Header), 
            send_file(S, bump(Header), 
                        OffSet + Need, Stop, Socket, &lt;&lt;&gt;&gt;) 
    end. 

write_data(Socket, B0, B1, Header) -&gt; 
    %% Проверим, действительно ли данные для отправки имеют нужную длину. 
    %% это очень полезная проверка, которая проверяет нашу программу на корректность. 
    case size(B0) + size(B1) of 
        ?CHUNKSIZE -&gt; 
            case gen_tcp:send(Socket, [B0, B1, the_header(Header)]) of 
                ok -&gt; true; 
                {error, closed} -&gt; 
                    %% это происходит, если медиаплеер 
                    %% прерывает соединение. 
                    exit(playerClosed) 
            end; 
        _Other -&gt; 
            %% не посылаем блок,а сигнализируем об ошибке. 
            io:format(&quot;Block length Error: B0 = ~p b1=~p~n&quot; , 
                        [size(B0), size(B1)]) 
    end. 

bump({K, H}) -&gt; {K+1, H}. 

the_header({K, H}) -&gt; 
    case K rem 5 of 
        0 -&gt; H; 
        _ -&gt; &lt;&lt;0&gt;&gt; 
    end. 

is_request_for_stream(_) -&gt; true. 

response() -&gt; 
    [&quot;ICY 200 OK\r\n&quot; , 
    &quot;icy-notice1: &lt;BR&gt;This stream requires&quot; , 
    &quot;&lt;a href=\&quot; http://www.winamp.com/\&quot;&gt;Winamp&lt;/a&gt;&lt;BR&gt;\r\n&quot; , 
    &quot;icy-notice2: Erlang Shoutcast server&lt;BR&gt;\r\n&quot; , 
    &quot;icy-name: Erlang mix\r\n&quot; , 
    &quot;icy-genre: Pop Top 40 Dance Rock\r\n&quot; , 
    &quot;icy-url: http://localhost:3000\r\n&quot; , 
    &quot;content-type: audio/mpeg\r\n&quot; , 
    &quot;icy-pub: 1\r\n&quot; , 
    &quot;icy-metaint: &quot; ,integer_to_list(?CHUNKSIZE),&quot;\r\n&quot; , 
    &quot;icy-br: 96\r\n\r\n&quot;]. 

songs() -&gt; 
    {ok,[SongList]} = file:consult(&quot;mp3data&quot; ), 
    lib_misc:random_seed(), 
    songs_loop(SongList). 

songs_loop(SongList) -&gt; 
    receive 
        {From, random_song} -&gt; 
            I = random:uniform(length(SongList)), 
            Song = lists:nth(I, SongList), 
            From ! {self(), Song}, 
            songs_loop(SongList) 
    end. 

rpc(Pid, Q) -&gt; 
    Pid ! {self(), Q}, 
    receive 
        {Pid, Reply} -&gt; 
            Reply 
    end. 

unpack_song_descriptor({File, {_Tag,Info}}) -&gt; 
    PrintStr = list_to_binary(make_header1(Info)), 
    L1 = [&quot;StreamTitle=’&quot; ,PrintStr,
            &quot;’;StreamUrl=’http://localhost:3000’;&quot; ], 
    %% io:format(&quot;L1=~p~n&quot;,[L1]), 
    Bin = list_to_binary(L1), 
    Nblocks = ((size(Bin) -1) div 16) + 1, 
    NPad = Nblocks*16 -size(Bin), 
    Extra = lists:duplicate(NPad, 0), 
    Header = list_to_binary([Nblocks, Bin, Extra]), 
    %% Header это блок метаданных. 
    {File, PrintStr, Header}. 

make_header1([{track,_}|T]) -&gt; 
    make_header1(T); 
make_header1([{Tag,X}|T]) -&gt; 
    [atom_to_list(Tag),&quot;: &quot; ,X,&quot; &quot; |make_header1(T)]; 
make_header1([]) -&gt;
    []. 
</code></pre><h3 id="14-7-4-shoutcast-">14.7.4 Запустим SHOUTcast сервер</h3>
<p>Запустим сервер, и проверим, как он работает, нам необходимо выполнить три шага: </p>
<ol>
<li><p>Создать плейлист. </p>
</li>
<li><p>Запустить сервер. </p>
</li>
<li><p>Настроить клиент для работы с сервером. </p>
</li>
</ol>
<h3 id="14-7-5-">14.7.5 Создание плейлиста</h3>
<p>Для создания плейлиста нам надо выполнить следующие шаги: </p>
<ol>
<li><p>Перейти в каталог, где лежит модуль <code>mp3_manager.erl</code>(9) </p>
</li>
<li><p>Изменить путь в функции <code>start1</code>, которая находится в файле <code>mp3_manager.erl</code>, на путь, который указывает на каталог с MP3 файлами. </p>
</li>
<li><p>Скомпилировать <code>mp3_manager</code>, и набрать в оболочке <code>mp3_manager:start1()</code>. Мы должны увидеть что-то вроде этого: </p>
<pre><code> 1&gt; c(mp3_manager). 
 {ok,mp3_manager} 
 2&gt; mp3_manager:start1(). 
 Dumping term to mp3data 
 ok 
</code></pre></li>
</ol>
<p>Если вам интересно, то вы можете взглянуть на файл <code>mp3data</code>, что бы увидеть результаты анализа. </p>
<h3 id="14-7-6-shoutcast-">14.7.6 Запуск SHOUTcast сервера</h3>
<p>Запустим сервер из оболочки следующей командой: </p>
<pre><code>1&gt; shout:start(). 
... 
</code></pre><h3 id="14-7-7-">14.7.7 Тестирование сервера</h3>
<ol>
<li><p>Запустим плеер и укажем в его найтройках адрес сервера: <code>http://localhost:3000</code>
На моей системе я использовал XMMS, которого запустил следующей командой: xmms <code>http://localhost:3000</code></p>
<p> Примечание: если вы хотите подключиться к серверу с другой машины, вы должны 
указать IP адрес сервера. Например, что бы подключиться к серверу с моей Windows машины, на которой установлен winamp, я вызвал Play &gt; URL меню в винампе и ввел адрес <code>http://192.168.1.168:3000</code> в диалоговом окне Open URL на моем iMac я использовал iTunes,я вызвал Advanced &gt; Open Stream меню и вписал в него предыдущий url. </p>
</li>
<li><p>Вы увидите диагностический вывод в окне, в котором запущен сервер. </p>
</li>
<li><p>Enjoy! </p>
</li>
</ol>
<p><em>(9) тот самый модуль из предыдущей главы, где мы извлекали метаданные из MP3 файлов.</em></p>
<h2 id="14-8-">14.8 Копаем глубже</h2>
<p>В этой главе мы рассмотрели наиболее часто используемые функции для манипулирования сокетами. Вы можете найти больше информации о socket API в документации, на страницах <code>gen_tcp</code>, <code>gen_udp</code>, и <code>inet</code>.</p>

		</div>
		
		
		<!-- pagination -->
		<nav>

	<ul class="pager">
  <li class="previous"><a href="http://erlangbook.tk/13" title="Previous Post: Глава 13. Работа с файлами" class="navlinks-prev"><span class="glyphicon glyphicon-arrow-left" aria-hidden="true"></span> Глава 13. Работа с файлами</a></li>
  <li class="next"><a href="http://erlangbook.tk/15" title="Next Post: Глава 15. ETS и DETS:" class="navlinks-next">Глава 15. ETS и DETS: <span class="glyphicon glyphicon-arrow-right" aria-hidden="true"></span></a></li>
</ul>

</nav>

		
		
		<!-- footer -->
		<footer>
			<div class="container" >
			<div class="row" >
			<div class="col-sm-1">
<!--LiveInternet logo--><a href="//www.liveinternet.ru/click"
target="_blank"><img src="//counter.yadro.ru/logo?52.6"
title="LiveInternet: �������� ����� ���������� � ����������� �� 24 ����"
alt="" border="0" width="88" height="31"/></a><!--/LiveInternet-->
</div>

			<div class="col-sm-11">
<script language="JavaScript" src="http://r1.wmlink.ru/?id=422948"></script>
</div>

			</div>
			</div>
			
			<p>
	&copy; 2015 <a href="http://erlangbook.tk">erlangbook.tk</a>
</p>

		</footer>
	</div>

	<!-- Bootstrap core JavaScript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<!-- Latest compiled and minified JavaScript -->
	<script src="http://erlangbook.tk/js/bootstrap.min.js"></script>
	<script src="http://erlangbook.tk/js/docs.js"></script>

<!--bootstrap material design-->
        <script src="http://erlangbook.tk/js/ripples.min.js"></script>
        <script src="http://erlangbook.tk/js/material.min.js"></script>
        <script>
            $(document).ready(function() {
                $.material.init();
            });
        </script>

</body>
</html>